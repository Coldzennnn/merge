<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Among Us Merge: Final Release</title>

    <script src="/sdk.js"></script>

    <style>
        /* 1. GLOBAL RESET & MOBILE OPTIMIZATION */
        * {
            box-sizing: border-box;
            outline: none;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            touch-action: none;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            overflow: hidden;
            font-family: 'Arial Black', 'Verdana', sans-serif;
            overscroll-behavior: none;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        /* --- UI OVERLAYS --- */
        .overlay {
            display: none;
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 100;
            align-items: center;
            justify-content: center;
            color: white;
            flex-direction: column;
        }

        /* Rotate Overlay (New) */
        #rotateOverlay {
            background: rgba(0, 0, 0, 0.95);
            z-index: 99999;
        }

        .phone-icon {
            width: 60px;
            height: 100px;
            border: 4px solid #FFA500;
            border-radius: 10px;
            margin-bottom: 30px;
            position: relative;
            animation: rotateIcon 2.5s infinite ease-in-out;
        }
        .phone-icon::after {
            content: '';
            position: absolute;
            top: 5px; left: 50%; transform: translateX(-50%);
            width: 40px; height: 2px; background: #FFA500;
        }

        @keyframes rotateIcon {
            0% { transform: rotate(0deg); opacity: 1; }
            40% { transform: rotate(90deg); opacity: 1; }
            80% { transform: rotate(90deg); opacity: 0; }
            100% { transform: rotate(0deg); opacity: 0; }
        }

        #rotateMsg {
            font-family: 'Arial Black', sans-serif;
            font-size: 20px;
            color: white;
            text-align: center;
            padding: 0 20px;
            text-transform: uppercase;
        }

        /* Loading Screen */
        #loadingOverlay {
            z-index: 9999;
            background: #000;
            display: flex;
        }

        /* Popup Styles - Responsive using CSS Clamp */
        .popup-box {
            position: relative;
            width: clamp(280px, 80vw, 400px);
            background: #222;
            border: 3px solid #FFA500;
            border-radius: 15px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            box-shadow: 0 0 30px rgba(255, 165, 0, 0.5);
        }

        .challenge-title { font-family: 'Arial Black', sans-serif; font-size: clamp(20px, 5vw, 30px); color: #FFA500; text-transform: uppercase; letter-spacing: 2px; text-align: center; -webkit-text-stroke: 1px black; margin-bottom: 15px; }
        .enemy-avatar-placeholder { width: 80px; height: 80px; background: #500; border-radius: 50%; margin-bottom: 10px; border: 2px solid #F00; display: flex; align-items: center; justify-content: center; font-size: 40px; }
        .enemy-name { font-size: 20px; font-weight: bold; margin-bottom: 20px; color: #FFF; }
        .btn-group { display: flex; gap: 10px; width: 100%; }
        
        button { font-family: inherit; }

        .btn-accept { flex: 1; padding: 10px; border: none; border-radius: 5px; background: #00AA00; color: white; font-weight: bold; cursor: pointer; text-transform: uppercase; border: 2px solid #005500; }
        .btn-decline { flex: 1; padding: 10px; border: none; border-radius: 5px; background: #555; color: #AAA; font-weight: bold; cursor: pointer; text-transform: uppercase; border: 2px solid #333; }

        /* Setup & Battle UI - REFACTORED FOR RESPONSIVENESS */
        .battle-header { 
            font-family: 'Arial Black', sans-serif; 
            font-size: clamp(20px, 5vw, 40px); 
            color: #FFA500; 
            text-transform: uppercase; 
            margin-bottom: 10px; 
            text-shadow: 2px 2px 0 #000; 
            text-align: center; 
            flex-shrink: 0;
        }
        .setup-arena { 
            display: flex; 
            width: 95%; 
            max-width: 800px; 
            height: 60vh; /* Responsive Height */
            max-height: 500px;
            border: 2px solid #444; 
            background: #222; 
            border-radius: 10px; 
            overflow: hidden; 
            margin-bottom: 20px; 
            flex-direction: row; /* Force row layout */
        }
        .side { 
            flex: 1; 
            padding: 5px; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            overflow-y: auto; /* Scrollable list */
            overflow-x: hidden;
        }
        .side.enemy { background: #2C0000; border-left: 2px solid #444; }
        .side.player { background: #111; }
        .side-title { font-size: clamp(14px, 4vw, 18px); margin-bottom: 10px; color: #AAA; text-align: center; font-weight: bold; text-shadow: 1px 1px 0 #000; }

        .unit-card { 
            width: clamp(50px, 12vw, 80px); 
            height: clamp(70px, 16vw, 100px); 
            background: #333; 
            margin: 3px; 
            border-radius: 8px; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center; 
            border: 2px solid transparent; 
            cursor: pointer; 
            position: relative; 
            flex-shrink: 0;
        }
        .unit-card.selected { border-color: #00FF00; background: #003300; box-shadow: 0 0 10px #00FF00; }
        .unit-card.mystery { background: #1a1a1a; border: 2px dashed #555; color: #555; font-size: 30px; font-weight: bold; cursor: default; }
        .unit-body { width: 50%; height: 50%; border-radius: 10px; border: 2px solid black; position: relative; margin-bottom: 5px; }
        .unit-visor { width: 70%; height: 40%; background: #75D5E6; border-radius: 50%; position: absolute; top: 20%; left: 50%; transform: translateX(-50%); border: 1px solid black; }

        .action-btn { padding: 15px 40px; font-size: 24px; background: #FF0000; color: white; border: 2px solid #500; border-radius: 5px; cursor: pointer; text-transform: uppercase; font-weight: bold; box-shadow: 0 4px 0 #500; }
        .action-btn:active { box-shadow: 0 2px 0 #500; transform: translateY(2px); }
        .action-btn:disabled { background: #555; border-color: #333; box-shadow: none; cursor: not-allowed; opacity: 0.5; transform: none; }

        /* Media Query for Landscape Mobile / Short Screens */
        @media (max-height: 500px) {
            .setup-arena { 
                height: 65vh !important; /* Force 65% height */
                margin-bottom: 5px; 
            }
            .unit-card { 
                width: 50px !important;
                height: 70px !important;
                margin: 2px !important;
                transform: none !important; /* Remove clamp transform logic if any */
            }
            .battle-header { 
                font-size: 18px !important; 
                margin-bottom: 2px; 
            }
            .action-btn { 
                padding: 5px 20px !important; 
                font-size: 16px !important; 
                margin-top: 2px;
            }
            /* Ensure text fits */
            .side-title { font-size: 12px !important; margin-bottom: 2px; }
            .unit-card .unit-body { margin-bottom: 2px; }
            .unit-card div { font-size: 9px !important; }
        }

        #playerSquadList, #enemyContainer { display: flex; flex-wrap: wrap; justify-content: center; width: 100%; align-content: flex-start; }

        /* Result */
        .result-title { font-family: 'Arial Black', sans-serif; font-size: 40px; margin-bottom: 20px; -webkit-text-stroke: 2px black; letter-spacing: 2px; }
        .win { color: #00FF00; } .lose { color: #FF0000; }
        .dead-list { color: #FF5555; margin-top: 10px; font-size: 14px; font-weight: bold; text-shadow: 1px 1px 0 #000; }
    </style>
</head>
<body oncontextmenu="return false;" ondragstart="return false;">

    <canvas id="gameCanvas"></canvas>

    <!-- NEW ROTATE OVERLAY -->
    <div id="rotateOverlay" class="overlay">
        <div class="phone-icon"></div>
        <div id="rotateMsg">Please rotate your device</div>
    </div>

    <div id="loadingOverlay" class="overlay">
        <!-- Added ID for localization -->
        <h1 id="loadingText" style="color: #666; font-size: 24px; font-family: 'Arial Black';">LOADING...</h1>
    </div>

    <div id="challengeOverlay" class="overlay">
        <div class="popup-box">
            <div class="challenge-title" id="chalTitle">FAIR FIGHT!</div>
            <div class="enemy-avatar-placeholder">‚öîÔ∏è</div>
            <div class="enemy-name" id="chalName">PlayerName</div>
            <div class="btn-group">
                <button class="btn-decline" id="btnDecline">Decline</button>
                <button class="btn-accept" id="btnAccept">Accept</button>
            </div>
        </div>
    </div>

    <div id="battleSetupOverlay" class="overlay">
        <div class="battle-header" id="setupTitle">PREPARE SQUAD</div>
        <div class="setup-arena">
            <div class="side player">
                <div class="side-title"><span id="squadTitle">Your Squad</span> <span id="squadCount" style="color:#0F0">(0/5)</span></div>
                <div id="playerSquadList"></div>
                <!-- Added ID for Power Label -->
                <div style="margin-top:10px; font-size: 14px; color: #8F8; font-weight: bold; text-shadow: 1px 1px 0 #000;"><span id="squadPowerLabel">Power</span>: <span id="squadPower">0</span></div>
            </div>
            <div class="side enemy">
                <div class="side-title" id="enemyTitle">Hidden Enemy</div>
                <!-- Added ID for Hidden Label -->
                <div id="hiddenLabel" style="color: #FF5555; font-size: 12px; margin-bottom: 5px; letter-spacing: 1px; font-weight: bold;">OPPONENT HIDDEN</div>
                <div id="enemyContainer"></div>
                <!-- Added ID for Power Label -->
                <div style="margin-top:10px; font-size: 14px; color: #F88; font-weight: bold; text-shadow: 1px 1px 0 #000;"><span id="enemyPowerLabel">Power</span>: <span id="enemyPower">???</span></div>
            </div>
        </div>
        <button class="action-btn" id="fightBtn" disabled>FIGHT</button>
    </div>

    <div id="battleResultOverlay" class="overlay">
        <div class="result-title" id="resultTitle">VICTORY</div>
        <div id="resultReward" style="font-size: 28px; color: gold; margin-bottom: 20px; font-family: 'Arial Black'; -webkit-text-stroke: 1.5px black;"></div>
        <div id="deadHeroesBlock" style="display:none; margin-bottom: 20px;">
            <div style="color: #AAA;" id="fallenTitle">Fallen Heroes:</div>
            <div class="dead-list" id="deadListText"></div>
        </div>
        <button class="action-btn" id="continueBtn" style="background:#4CAF50; border-color: #2E7D32; box-shadow: 0 4px 0 #2E7D32;">CONTINUE</button>
    </div>

<script>
    // 1. INPUT BLOCKING & UTILS
    window.addEventListener('contextmenu', e => { e.preventDefault(); return false; }, { passive: false });
    window.addEventListener('selectstart', e => { e.preventDefault(); return false; }, { passive: false });
    window.addEventListener('dragstart', e => { e.preventDefault(); return false; }, { passive: false });
    
    // Prevent default touch behaviors but DO NOT block the canvas touchstart logic
    document.addEventListener('touchstart', e => {
        if (e.target.closest('button') || e.target.closest('.unit-card')) return;
        if (!e.target.closest('.overlay') && e.target.tagName !== 'CANVAS') e.preventDefault(); 
    }, { passive: false });

    // 2. AUDIO SYSTEM
    class SoundManager {
        constructor() {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            this.masterGain = this.ctx.createGain();
            this.masterGain.connect(this.ctx.destination);
            this.muted = localStorage.getItem('amg-mute') === 'true';
            this.musicPlaying = false;
            this.updateGain();
        }

        setMute(isMuted) {
            this.muted = isMuted;
            localStorage.setItem('amg-mute', isMuted);
            this.updateGain();
            if (this.ctx && this.ctx.state === 'suspended' && !this.muted) {
                try { this.ctx.resume(); } catch(e){}
            }
            return this.muted;
        }

        muteForAd() { if (this.ctx) this.ctx.suspend(); }
        unmuteFromAd() { if (this.ctx && !this.muted) this.ctx.resume(); }

        updateGain() {
            this.masterGain.gain.setValueAtTime(this.muted ? 0 : 0.3, this.ctx.currentTime);
        }

        checkContext() {
            if (this.ctx && this.ctx.state === 'suspended') {
                try { this.ctx.resume(); } catch(e){}
            }
            if (!this.musicPlaying && !this.muted) this.startMusic();
        }

        _playSoftTone(freq, type, duration, vol = 0.2, pitchSlideTo = null) {
            if (this.muted || !this.ctx) return;
            const t = this.ctx.currentTime;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();

            osc.type = type;
            osc.frequency.setValueAtTime(freq, t);
            if (pitchSlideTo) {
                osc.frequency.exponentialRampToValueAtTime(pitchSlideTo, t + duration);
            }

            gain.connect(this.masterGain);
            osc.connect(gain);

            gain.gain.setValueAtTime(0, t);
            gain.gain.linearRampToValueAtTime(vol, t + 0.05); 
            gain.gain.exponentialRampToValueAtTime(0.001, t + duration); 

            osc.start(t);
            osc.stop(t + duration + 0.1);
        }

        playClick() { this._playSoftTone(400, 'sine', 0.15, 0.15, 200); }
        playMerge() { this._playSoftTone(300, 'sine', 0.3, 0.25, 800); setTimeout(() => this._playSoftTone(500, 'sine', 0.4, 0.1, 1200), 50); }
        playBuy() { this._playSoftTone(1200, 'sine', 0.1, 0.1); setTimeout(() => this._playSoftTone(1800, 'sine', 0.2, 0.1), 50); }
        playAttack() { this._playSoftTone(200, 'triangle', 0.2, 0.1, 50); }
        playHit() { this._playSoftTone(100, 'triangle', 0.1, 0.15, 50); }
        playWin() { [523.25, 659.25, 783.99, 1046.50].forEach((freq, i) => { setTimeout(() => this._playSoftTone(freq, 'sine', 0.4, 0.2), i * 100); }); }
        playLose() { this._playSoftTone(400, 'triangle', 0.5, 0.2, 100); }

        startMusic() {
            if (this.musicPlaying || this.muted) return;
            this.musicPlaying = true;
            const notes = [261.63, 329.63, 392.00, 523.25];
            let noteIdx = 0;
            const playNote = () => {
                if (!this.musicPlaying) return;
                if (!this.muted && this.ctx && this.ctx.state === 'running') {
                    const freq = notes[noteIdx % notes.length];
                    const rFreq = freq + (Math.random() * 10 - 5);
                    this._playSoftTone(rFreq, 'sine', 2.0, 0.05); 
                    noteIdx++;
                    setTimeout(playNote, 2000 + Math.random() * 2000);
                } else {
                    setTimeout(playNote, 1000);
                }
            };
            playNote();
        }
    }

    // 3. YANDEX SDK MANAGER
    class YandexManager {
        constructor() { this.ysdk = null; this.lang = 'en'; this.isMock = false; }

        async init() {
            const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error("SDK Timeout")), 2000));
            const sdkPromise = new Promise(async (resolve, reject) => {
                 if (window.YaGames) { try { resolve(await window.YaGames.init()); } catch (e) { reject(e); } } 
                 else {
                     let tries = 0;
                     const i = setInterval(async () => {
                        tries++;
                        if (window.YaGames) { clearInterval(i); resolve(await window.YaGames.init()); }
                        if (tries > 20) { clearInterval(i); reject(new Error("No SDK script")); }
                     }, 100);
                 }
            });

            try {
                this.ysdk = await Promise.race([sdkPromise, timeoutPromise]);
                const urlParams = new URLSearchParams(window.location.search);
                const urlLang = urlParams.get('lang');
                const envLang = this.ysdk.environment.i18n.lang;
                this.lang = ['ru', 'be', 'kk', 'uk', 'uz'].includes(urlLang || envLang) ? 'ru' : 'en';
            } catch (e) {
                console.warn("SDK Failed. Mock Mode.");
                this.isMock = true; this.lang = 'ru';
            }
            gameState.lang = this.lang;
        }

        notifyGameReady() {
            if (this.ysdk && this.ysdk.features.LoadingAPI) {
                this.ysdk.features.LoadingAPI.ready();
            }
        }

        gameplayStart() { if (this.ysdk && this.ysdk.features.GameplayAPI) this.ysdk.features.GameplayAPI.start(); }
        gameplayStop() { if (this.ysdk && this.ysdk.features.GameplayAPI) this.ysdk.features.GameplayAPI.stop(); }

        showInterstitial(cb) {
            if (this.isMock) { if(cb) cb(); return; }
            this.gameplayStop();
            this.ysdk.adv.showFullscreenAdv({ 
                callbacks: { 
                    onOpen: () => { soundManager.muteForAd(); },
                    onClose: () => { soundManager.unmuteFromAd(); this.gameplayStart(); if (cb) cb(); }, 
                    onError: () => { soundManager.unmuteFromAd(); this.gameplayStart(); if (cb) cb(); } 
                } 
            });
        }

        showRewarded(onReward) {
            if (this.isMock) { onReward(); return; }
            this.gameplayStop();
            this.ysdk.adv.showRewardedVideo({
                callbacks: {
                    onOpen: () => { soundManager.muteForAd(); },
                    onRewarded: () => { onReward(); },
                    onClose: () => { soundManager.unmuteFromAd(); this.gameplayStart(); },
                    onError: () => { soundManager.unmuteFromAd(); this.gameplayStart(); }
                }
            });
        }
    }

    // 4. GAME LOGIC & CONFIG
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const soundManager = new SoundManager();
    const yandexManager = new YandexManager();

    const CONFIG = {
        gridRows: 3, gridCols: 5, slotSize: 0, slotMargin: 10,
        BASE_INCOME: 2, INCOME_MULTIPLIER: 2.1,
        BASE_COST: 60, PRICE_MULTIPLIER: 2.3,
        HP_BASE: 80, HP_MULT: 1.4,
        DMG_BASE: 12, DMG_MULT: 1.35,
        BATTLE_INTERVAL_MIN: 45, SQUAD_LIMIT: 5,
        gridColor: '#23272A'
    };
    
    const layout = {
        isPortrait: false,
        scale: 1,
        gridX: 0,
        gridY: 0,
        fontSize: 16
    };

    const NICKNAMES = ["Shadow", "Viper", "Ghost", "MadMax", "Cyber", "Wolf", "Storm", "Pro", "Speed", "Doom", "Alpha", "Venom", "Kratos", "Loki", "Zero"];
    
    // --- 1. THE COMPLETE DICTIONARY ---
    const TRANSLATION = {
        en: {
            LOADING: "LOADING...",
            COINS: "Coins",
            LVL: "Lvl",
            AD_BTN: "Ad", 
            AD_FULL: "Watch Ad",
            SETTINGS: "SETTINGS",
            SOUND: "Sound",
            LANG: "Language",
            ROTATE: "Please rotate your device",
            // Challenge
            CHALLENGE: "CHALLENGE!",
            ACCEPT: "FIGHT",
            DECLINE: "FLEE",
            // Battle Setup
            PREPARE: "PREPARE SQUAD",
            SQUAD: "Your Squad",
            ENEMY: "Hidden Enemy",
            HIDDEN: "OPPONENT HIDDEN",
            POWER: "Power",
            FIGHT_BTN: "ATTACK",
            // Battle Result
            WIN: "VICTORY!",
            LOSE: "DEFEAT",
            REWARD: "Reward",
            FALLEN: "Fallen Heroes:",
            CONTINUE: "CONTINUE",
            // Floating Text
            NO_MONEY: "Not enough money!",
            MAX_LVL: "Max Level!",
            // New Keys
            CRIT: "CRIT!",
            UNITS_LOST: "units"
        },
        ru: {
            LOADING: "–ó–ê–ì–†–£–ó–ö–ê...",
            COINS: "–ú–æ–Ω–µ—Ç—ã",
            LVL: "–£—Ä.",
            AD_BTN: "–†–µ–∫–ª–∞–º–∞", 
            AD_FULL: "–°–º–æ—Ç—Ä–µ—Ç—å —Ä–µ–∫–ª–∞–º—É",
            SETTINGS: "–ù–ê–°–¢–†–û–ô–ö–ò",
            SOUND: "–ó–≤—É–∫",
            LANG: "–Ø–∑—ã–∫",
            ROTATE: "–ü–µ—Ä–µ–≤–µ—Ä–Ω–∏—Ç–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ",
            // Challenge
            CHALLENGE: "–í–´–ó–û–í!",
            ACCEPT: "–í –ë–û–ô",
            DECLINE: "–°–ë–ï–ñ–ê–¢–¨",
            // Battle Setup
            PREPARE: "–í–´–ë–û–† –û–¢–†–Ø–î–ê",
            SQUAD: "–í–∞—à –æ—Ç—Ä—è–¥",
            ENEMY: "–í—Ä–∞–≥",
            HIDDEN: "–°–ö–†–´–¢–´–ô –ü–†–û–¢–ò–í–ù–ò–ö",
            POWER: "–°–∏–ª–∞",
            FIGHT_BTN: "–í –ê–¢–ê–ö–£",
            // Battle Result
            WIN: "–ü–û–ë–ï–î–ê!",
            LOSE: "–ü–û–†–ê–ñ–ï–ù–ò–ï",
            REWARD: "–ù–∞–≥—Ä–∞–¥–∞",
            FALLEN: "–ü–æ—Ç–µ—Ä–∏:",
            CONTINUE: "–î–ê–õ–ï–ï",
            // Floating Text
            NO_MONEY: "–ú–∞–ª–æ –¥–µ–Ω–µ–≥!",
            MAX_LVL: "–ú–∞–∫—Å. —É—Ä–æ–≤–µ–Ω—å!",
            // New Keys
            CRIT: "–ö–†–ò–¢!",
            UNITS_LOST: "–µ–¥."
        }
    };

    let gameState = { mode: 'MERGE', coins: 0, units: [], maxLevel: 1, lang: 'en', challengeTimer: 60, enemySquad: [], selectedUnitIds: [], paused: false, settingsOpen: false };
    let battleState = { playerTeam: [], enemyTeam: [], projectiles: [], phase: 'INIT', phaseTimer: 0, deadUnitIds: [] };
    let renderState = { slots: [], effects: [], floatingTexts: [], uiButtons: [], stars: [] };

    // UTILS
    function getBuyCost(level) { return Math.floor(CONFIG.BASE_COST * Math.pow(CONFIG.PRICE_MULTIPLIER, level - 1)); }
    function getClickIncome(level) { return Math.floor(CONFIG.BASE_INCOME * Math.pow(CONFIG.INCOME_MULTIPLIER, level - 1)); }
    function getStats(level) { return { hp: Math.floor(CONFIG.HP_BASE * Math.pow(CONFIG.HP_MULT, level - 1)), dmg: Math.floor(CONFIG.DMG_BASE * Math.pow(CONFIG.DMG_MULT, level - 1)) }; }
    function calculatePower(level) { return 10 * Math.pow(2, level - 1); }
    function getAdRewardAmount() { return getBuyCost(gameState.maxLevel) * 3; }

    function formatNumber(num) {
        if (num < 1000) return Math.floor(num).toString();
        const suffixes = ["", "k", "M", "B", "T", "aa", "bb", "cc", "dd", "ee", "ff", "gg"];
        const suffixNum = Math.floor(Math.log10(num) / 3);
        if (suffixNum >= suffixes.length) return "MAX";
        const shortValue = (num / Math.pow(1000, suffixNum)).toPrecision(3);
        return parseFloat(shortValue) + suffixes[suffixNum];
    }
    
    function getUnitColor(level) {
        const hue = (level * 137.508) % 360; 
        return `hsl(${hue}, 70%, 50%)`;
    }

    function getSmartShopState() {
        const targetLevel = Math.max(1, gameState.maxLevel - 3);
        const counts = {}; gameState.units.forEach(u => { counts[u.level] = (counts[u.level] || 0) + 1; });
        const levels = Object.keys(counts).map(Number).sort((a,b) => a - b);
        let minOddLevel = -1;
        for (let lvl of levels) { if (counts[lvl] % 2 !== 0) { minOddLevel = lvl; break; } }
        if (minOddLevel !== -1 && minOddLevel < targetLevel) return { level: minOddLevel, type: 'HELP' };
        return { level: targetLevel, type: 'STANDARD' };
    }

    // GAME LOOP
    let lastTime = 0;
    function gameLoop(ts) {
        if (!gameState.paused) {
            if (!lastTime) lastTime = ts; const dt = (ts - lastTime) / 1000; lastTime = ts;
            if (gameState.mode === 'MERGE') { gameState.challengeTimer -= dt; if (gameState.challengeTimer <= 0) openChallenge(); }
            else if (gameState.mode === 'BATTLE') { updateBattle(dt); }
            render();
        } else {
            // Even if paused, redraw once to prevent black screen if stuck
            render();
        }
        requestAnimationFrame(gameLoop);
    }

    function openChallenge() {
        gameState.mode = 'CHALLENGE';
        const name = NICKNAMES[Math.floor(Math.random() * NICKNAMES.length)];
        gameState.enemySquad = [];
        const roll = Math.random(); let count, levelBase;
        if (roll < 0.75) { count = Math.floor(Math.random() * 3) + 1; levelBase = gameState.maxLevel - 1; } 
        else { count = Math.floor(Math.random() * 2) + 4; levelBase = gameState.maxLevel; }
        for(let i=0; i<count; i++) gameState.enemySquad.push({ level: Math.max(1, levelBase) });
        updateDomTexts();
        document.getElementById('chalName').innerText = name;
        document.getElementById('challengeOverlay').style.display = 'flex';
    }
    document.getElementById('btnDecline').onclick = () => {
        if (Math.random() > 0.7) yandexManager.showInterstitial();
        gameState.challengeTimer = CONFIG.BATTLE_INTERVAL_MIN + Math.random() * 15;
        gameState.mode = 'MERGE';
        document.getElementById('challengeOverlay').style.display = 'none';
    };
    document.getElementById('btnAccept').onclick = () => { document.getElementById('challengeOverlay').style.display = 'none'; openSetup(); };

    function openSetup() {
        gameState.mode = 'SETUP'; gameState.selectedUnitIds = [];
        const sorted = [...gameState.units].sort((a,b) => b.level - a.level).slice(0, 5);
        gameState.selectedUnitIds = sorted.map(u => u.id);
        renderSetupUI(); document.getElementById('battleSetupOverlay').style.display = 'flex';
    }
    
    function renderSetupUI() {
        updateDomTexts();
        document.getElementById('squadCount').innerText = `(${gameState.selectedUnitIds.length}/${CONFIG.SQUAD_LIMIT})`;
        const enemyCont = document.getElementById('enemyContainer'); enemyCont.innerHTML = '';
        for(let i=0; i<5; i++) { const el = document.createElement('div'); el.className = 'unit-card mystery'; el.innerText = '?'; enemyCont.appendChild(el); }
        const list = document.getElementById('playerSquadList'); list.innerHTML = '';
        let playerTotalPower = 0;
        [...gameState.units].sort((a,b)=>b.level-a.level).forEach(u => {
            const el = document.createElement('div'); el.className = 'unit-card';
            if (gameState.selectedUnitIds.includes(u.id)) { el.classList.add('selected'); playerTotalPower += calculatePower(u.level); }
            if (!gameState.selectedUnitIds.includes(u.id) && gameState.selectedUnitIds.length >= CONFIG.SQUAD_LIMIT) el.style.opacity = '0.5';
            el.innerHTML = `<div class="unit-body" style="background:${getUnitColor(u.level)}"><div class="unit-visor"></div></div><div style="color:white;font-size:10px; font-weight:bold; -webkit-text-stroke: 0.5px black;">${TRANSLATION[gameState.lang].LVL} ${u.level}</div>`;
            el.onclick = () => {
                const idx = gameState.selectedUnitIds.indexOf(u.id);
                if(idx !== -1) gameState.selectedUnitIds.splice(idx, 1);
                else if (gameState.selectedUnitIds.length < CONFIG.SQUAD_LIMIT) gameState.selectedUnitIds.push(u.id);
                soundManager.playClick(); renderSetupUI(); 
            };
            list.appendChild(el);
        });
        document.getElementById('squadPower').innerText = formatNumber(playerTotalPower);
        document.getElementById('fightBtn').disabled = gameState.selectedUnitIds.length === 0;
    }
    document.getElementById('fightBtn').onclick = () => { if(gameState.selectedUnitIds.length > 0) { soundManager.playClick(); document.getElementById('battleSetupOverlay').style.display='none'; initBattleMode(); } };

    function initBattleMode() {
        gameState.mode = 'BATTLE'; 
        battleState.projectiles = []; 
        battleState.deadUnitIds = [];
        renderState.stars = []; 
        
        const w = window.innerWidth;
        const h = window.innerHeight;
        const unitSize = Math.max(30, Math.min(80, Math.min(w * 0.12, h * 0.15)));
        battleState.unitSize = unitSize;

        for(let i=0; i<50; i++) renderState.stars.push({x: Math.random()*w, y: Math.random()*h, size: Math.random()*2+1});
        
        const spacing = 10; 

        const positionTeam = (squad, xPos, isEnemy) => {
            const count = squad.length;
            if (count === 0) return [];
            const totalH = count * unitSize + (count - 1) * spacing;
            const startY = (h - totalH) / 2;
            return squad.map((u, i) => {
                const lvl = u.level;
                const stats = getStats(lvl);
                return { 
                    originalId: u.id || `enemy_${i}`, 
                    level: lvl, 
                    hp: stats.hp, maxHp: stats.hp, dmg: stats.dmg, 
                    x: xPos, 
                    y: startY + i * (unitSize + spacing) + (unitSize / 2), 
                    team: isEnemy ? 'enemy' : 'player' 
                };
            });
        };

        const playerUnits = gameState.selectedUnitIds.map(id => gameState.units.find(x => x.id === id)).filter(u => u);
        battleState.playerTeam = positionTeam(playerUnits, w * 0.15, false);
        battleState.enemyTeam = positionTeam(gameState.enemySquad, w * 0.85, true);
        
        battleState.phase = 'INIT'; 
        battleState.phaseTimer = 1.0; 
    }
    
    function updateBattle(dt) {
        for (let i = battleState.projectiles.length - 1; i >= 0; i--) {
            const p = battleState.projectiles[i];
            const dist = Math.hypot(p.target.x - p.x, p.target.y - p.y);
            if (dist < 20 || p.target.hp <= 0) {
                if (p.target.hp > 0) {
                    let dmg = p.owner.dmg; if(Math.random()<0.1) dmg *= 1.5;
                    p.target.hp -= dmg; soundManager.playHit();
                    spawnFloatingText(p.target.x, p.target.y-40, `-${formatNumber(dmg)}`, '#FF0000');
                    if (p.target.hp<=0) { p.target.hp=0; if(p.target.team==='player') battleState.deadUnitIds.push(p.target.originalId); }
                    renderState.effects.push({x: p.target.x, y: p.target.y, life: 10, color: '#FFF'});
                }
                battleState.projectiles.splice(i, 1);
            } else { p.x += ((p.target.x - p.x)/dist)*20; p.y += ((p.target.y - p.y)/dist)*20; }
        }
        if (battleState.phase === 'INIT') { battleState.phaseTimer -= dt; if(battleState.phaseTimer<=0) battleState.phase = 'PLAYER_FIRE'; }
        else if (battleState.phase === 'PLAYER_FIRE') { fireTeam(battleState.playerTeam, battleState.enemyTeam, '#0F0'); battleState.phase = 'WAIT_PLAYER'; }
        else if (battleState.phase === 'WAIT_PLAYER') { if(battleState.projectiles.length === 0) battleState.phase = 'CHECK_P'; }
        else if (battleState.phase === 'CHECK_P') { if(!battleState.enemyTeam.some(u => u.hp > 0)) finishBattle(true); else battleState.phase = 'ENEMY_FIRE'; }
        else if (battleState.phase === 'ENEMY_FIRE') { fireTeam(battleState.enemyTeam, battleState.playerTeam, '#F00'); battleState.phase = 'WAIT_ENEMY'; }
        else if (battleState.phase === 'WAIT_ENEMY') { if(battleState.projectiles.length === 0) battleState.phase = 'CHECK_E'; }
        else if (battleState.phase === 'CHECK_E') { if(!battleState.playerTeam.some(u => u.hp > 0)) finishBattle(false); else battleState.phase = 'PLAYER_FIRE'; }
    }
    function fireTeam(source, targets, color) {
        const aliveSrc = source.filter(u => u.hp > 0); const aliveTgt = targets.filter(u => u.hp > 0);
        if(aliveSrc.length && aliveTgt.length) {
            aliveSrc.forEach(u => {
                const t = aliveTgt[Math.floor(Math.random()*aliveTgt.length)];
                battleState.projectiles.push({x: u.x, y: u.y, target: t, owner: u, color: color});
            });
            soundManager.playAttack();
        }
    }
    function finishBattle(win) {
        gameState.mode = 'RESULT'; const t = TRANSLATION[gameState.lang] || TRANSLATION.en;
        document.getElementById('resultTitle').innerText = win ? t.WIN : t.LOSE;
        document.getElementById('resultTitle').className = win ? 'result-title win' : 'result-title lose';
        if (win) {
            const reward = getAdRewardAmount(); gameState.coins += reward;
            document.getElementById('resultReward').innerText = `${t.REWARD}: +${formatNumber(reward)}$`; soundManager.playWin();
        } else { document.getElementById('resultReward').innerText = ""; soundManager.playLose(); }
        const deadBlock = document.getElementById('deadHeroesBlock');
        if (battleState.deadUnitIds.length > 0) {
            deadBlock.style.display = 'block'; gameState.units = gameState.units.filter(u => !battleState.deadUnitIds.includes(u.id));
            document.getElementById('deadListText').innerText = `-${battleState.deadUnitIds.length} ${t.UNITS_LOST}`;
        } else { deadBlock.style.display = 'none'; }
        saveGame(); document.getElementById('battleResultOverlay').style.display = 'flex';
    }
    document.getElementById('continueBtn').onclick = () => {
        document.getElementById('battleResultOverlay').style.display = 'none';
        yandexManager.showInterstitial(() => { gameState.challengeTimer = CONFIG.BATTLE_INTERVAL_MIN + Math.random() * 15; gameState.mode = 'MERGE'; resize(); });
    };

    function initGrid() {
        renderState.slots = [];
        for(let r=0; r<CONFIG.gridRows; r++) {
            for(let c=0; c<CONFIG.gridCols; c++) {
                renderState.slots.push({
                    x: layout.gridX + c * (CONFIG.slotSize + CONFIG.slotMargin),
                    y: layout.gridY + r * (CONFIG.slotSize + CONFIG.slotMargin),
                    width: CONFIG.slotSize,
                    height: CONFIG.slotSize,
                    index: r * CONFIG.gridCols + c
                });
            }
        }
    }

    function updateUIButtons(w, h) {
        const minDim = Math.min(w, h);
        
        // Consistent Radius (~35-40px)
        let r = Math.max(35, minDim * 0.06);
        if (r > 50) r = 50; // Cap max size

        // 1. SETTINGS (Top-Left Fixed Safe Area)
        // Moved to 50,50 to avoid corner clipping
        const setX = 50;
        const setY = 50;
        
        const settingsBtn = { id:'settings', x: setX, y: setY, r: r * 0.8, color:'#777', visible: true };
        
        // Fan out downwards from settings
        const muteBtn = { id:'mute', x: setX, y: setY + r * 2.2, r: r * 0.7, color:'#444', visible: gameState.settingsOpen };
        const langBtn = { id:'lang', x: setX, y: setY + r * 4.4, r: r * 0.7, color:'#4488FF', visible: gameState.settingsOpen };

        // 2. RIGHT-SIDE ACTION BAR (Vertical Stack)
        // Fixed X coordinate to clear edge gestures
        const actionX = w - 70;
        const centerY = h / 2;

        // Ad Button (Stacked Above Center)
        const adBtn = { id:'ad', x: actionX, y: centerY - 60, r: r, color:'#FFD700', visible: true };

        // Buy Unit Button (Stacked Below Center)
        const buyBtn = { id:'buy', x: actionX, y: centerY + 60, r: r * 1.1, color:'#4CAF50', visible: true };

        renderState.uiButtons = [settingsBtn, muteBtn, langBtn, adBtn, buyBtn];
    }

    function resize() {
        const dpr = window.devicePixelRatio || 1;
        const w = window.innerWidth;
        const h = window.innerHeight;

        canvas.width = w * dpr;
        canvas.height = h * dpr;
        canvas.style.width = w + 'px';
        canvas.style.height = h + 'px';

        ctx.resetTransform();
        ctx.scale(dpr, dpr);

        const isPortrait = h > w;
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                         (navigator.maxTouchPoints > 0 && window.matchMedia("(hover: none)").matches);

        const rotOverlay = document.getElementById('rotateOverlay');
        const rotMsg = document.getElementById('rotateMsg');
        
        if (isMobile && isPortrait) {
            if(rotOverlay.style.display !== 'flex') {
                rotOverlay.style.display = 'flex';
                gameState.paused = true;
                if(soundManager.ctx && soundManager.ctx.state === 'running') soundManager.ctx.suspend();
            }
            rotMsg.innerText = (TRANSLATION[gameState.lang] || TRANSLATION.en).ROTATE;
            return; 
        } else {
            if(rotOverlay.style.display === 'flex') {
                rotOverlay.style.display = 'none';
                gameState.paused = false;
                if(soundManager.ctx && soundManager.ctx.state === 'suspended' && !soundManager.muted) soundManager.ctx.resume();
            }
        }

        layout.isPortrait = isPortrait; 
        layout.scale = Math.min(w, h) / 400; 
        layout.fontSize = Math.max(16, h * 0.035); 

        const uiPadding = 20;
        const topSafeZone = Math.max(60, h * 0.15); 
        
        let bottomSafeZone = uiPadding;
        let sideSafeZone = uiPadding;

        if (layout.isPortrait) {
            bottomSafeZone = h * 0.22; 
        } else {
            sideSafeZone = w * 0.18; 
        }

        const availW = w - (sideSafeZone * 2);
        const availH = h - topSafeZone - bottomSafeZone;

        const maxSlotW = (availW - (CONFIG.gridCols - 1) * CONFIG.slotMargin) / CONFIG.gridCols;
        const maxSlotH = (availH - (CONFIG.gridRows - 1) * CONFIG.slotMargin) / CONFIG.gridRows;
        CONFIG.slotSize = Math.floor(Math.min(maxSlotW, maxSlotH));
        
        const gridRealW = CONFIG.gridCols * CONFIG.slotSize + (CONFIG.gridCols - 1) * CONFIG.slotMargin;
        const gridRealH = CONFIG.gridRows * CONFIG.slotSize + (CONFIG.gridRows - 1) * CONFIG.slotMargin;

        layout.gridX = (w - gridRealW) / 2;
        layout.gridY = topSafeZone + (availH - gridRealH) / 2;

        initGrid();
        updateUIButtons(w, h);

        if (gameState.mode === 'MERGE') {
            gameState.units.forEach(u => {
                if (!u.isDragging) ret(u);
            });
        }
    }

    function drawStrokedText(text, x, y, size, color, align = 'center') {
        ctx.font = `900 ${size}px "Arial Black", Verdana, sans-serif`;
        ctx.textAlign = align;
        ctx.textBaseline = 'middle';
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = Math.max(3, size / 8); 
        ctx.lineJoin = 'round';
        ctx.strokeText(text, x, y);
        ctx.fillStyle = color;
        ctx.fillText(text, x, y);
    }

    function render() {
        ctx.clearRect(0, 0, canvas.width / window.devicePixelRatio, canvas.height / window.devicePixelRatio);
        const w = window.innerWidth;
        const h = window.innerHeight;

        if (gameState.mode === 'BATTLE') {
            ctx.fillStyle = '#0b0d17'; ctx.fillRect(0,0,w,h);
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';
            ctx.lineWidth = 2;
            ctx.strokeRect(w * 0.05, h * 0.05, w * 0.9, h * 0.9);

            ctx.fillStyle = '#FFF'; renderState.stars.forEach(s => { ctx.globalAlpha=Math.random()*0.5+0.5; ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, Math.PI*2); ctx.fill(); }); ctx.globalAlpha=1;
            
            const unitSize = battleState.unitSize || 60; 

            [...battleState.playerTeam, ...battleState.enemyTeam].forEach(u => {
                if(u.hp <= 0) return;
                const hpPct = u.hp/u.maxHp; 
                const barW = unitSize * 0.8;
                const barH = Math.max(4, unitSize * 0.1);
                const barY = -unitSize * 0.6; 

                ctx.fillStyle = '#333'; ctx.fillRect(u.x - barW/2, u.y + barY, barW, barH); 
                ctx.fillStyle = hpPct>0.5?'#0F0':'#F00'; ctx.fillRect(u.x - barW/2, u.y + barY, barW*hpPct, barH);
                
                ctx.save(); 
                ctx.translate(u.x, u.y); 
                if(u.team === 'enemy') ctx.scale(-1, 1); 
                drawCharacter(ctx, 0, 0, unitSize, u.level); 
                ctx.restore();
            });
            battleState.projectiles.forEach(p => { ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, 8, 0, Math.PI*2); ctx.fill(); ctx.shadowColor=p.color; ctx.shadowBlur=10; ctx.stroke(); ctx.shadowBlur=0; });
        
        } else {
            ctx.fillStyle = '#2c3e50'; ctx.fillRect(0,0,w,h);
            ctx.strokeStyle = 'rgba(255,255,255,0.05)'; ctx.lineWidth=2; ctx.beginPath();
            for(let x=0;x<=w;x+=50){ctx.moveTo(x,0);ctx.lineTo(x,h);} for(let y=0;y<=h;y+=50){ctx.moveTo(0,y);ctx.lineTo(w,y);} ctx.stroke();
            
            renderState.slots.forEach(s => { ctx.fillStyle = CONFIG.gridColor; ctx.beginPath(); ctx.roundRect(s.x, s.y, s.width, s.height, 10); ctx.fill(); ctx.strokeStyle='#383C41'; ctx.lineWidth=2; ctx.stroke(); });
            
            gameState.units.forEach(u => {
                if (u.animScale < 1.0) u.animScale = Math.min(1.0, u.animScale+0.1);
                const size = CONFIG.slotSize * 0.8; 
                
                ctx.save(); 
                ctx.translate(u.x, u.y); 
                
                let sX = 1 + (1-u.animScale)*0.5;
                let sY = u.animScale;

                if (!u.isDragging && gameState.mode === 'MERGE') {
                    const breath = 1 + Math.sin(Date.now() / 300) * 0.03;
                    sX *= breath;
                    sY *= breath;
                }

                ctx.scale(sX, sY);

                if(u.isDragging) { ctx.shadowColor='rgba(0,0,0,0.5)'; ctx.shadowBlur=15; ctx.shadowOffsetY=10; } 
                drawCharacter(ctx, 0, 0, size, u.level); 
                ctx.restore();
                
                // Unit Lvl Text (Localized)
                const t = TRANSLATION[gameState.lang] || TRANSLATION.en;
                drawStrokedText(`${t.LVL} ${u.level}`, u.x, u.y + size/2 + 15, Math.max(10, CONFIG.slotSize * 0.15), '#FFFFFF');
            });

            const t = TRANSLATION[gameState.lang] || TRANSLATION.en;

            // Money Top Center
            drawStrokedText(`$ ${formatNumber(gameState.coins)}`, w / 2, Math.max(30, h * 0.05), Math.max(24, h * 0.05), '#FFD700');

            renderState.uiButtons.forEach(btn => {
                if (!btn.visible) return;

                if(btn.id === 'buy') {
                    const s = getSmartShopState(); const cost = getBuyCost(s.level); const can = gameState.coins >= cost;
                    ctx.fillStyle = can ? btn.color : '#555'; ctx.beginPath(); ctx.arc(btn.x, btn.y, btn.r, 0, Math.PI*2); ctx.fill();
                    ctx.strokeStyle = (s.type === 'HELP' && can) ? '#FFA500' : '#FFF'; ctx.lineWidth = (s.type==='HELP')?4:2; ctx.stroke();
                    drawStrokedText(`${t.LVL} ${s.level}`, btn.x, btn.y - btn.r * 0.15, btn.r * 0.35, can?'#FFF':'#AAA');
                    drawStrokedText(`${formatNumber(cost)}$`, btn.x, btn.y + btn.r * 0.35, btn.r * 0.45, can?'#FFF':'#AAA');
                } 
                else if(btn.id === 'ad') {
                    ctx.fillStyle = btn.color; ctx.beginPath(); ctx.arc(btn.x, btn.y, btn.r, 0, Math.PI*2); ctx.fill(); 
                    ctx.strokeStyle = '#FFF'; ctx.lineWidth = 2; ctx.stroke();
                    
                    ctx.fillStyle = '#FFF'; ctx.beginPath();
                    const cx = btn.x + 2; const cy = btn.y - btn.r * 0.2; const s = btn.r * 0.3;
                    ctx.moveTo(cx - s, cy - s); ctx.lineTo(cx - s, cy + s); ctx.lineTo(cx + s, cy); ctx.fill();

                    // Ad Text (Localized)
                    ctx.font = `900 ${btn.r * 0.35}px "Arial Black", Verdana`;
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillStyle = '#000';
                    ctx.fillText(t.AD_BTN, btn.x, btn.y + btn.r * 0.4);

                    const rewardVal = getAdRewardAmount();
                    const rewardText = `+${formatNumber(rewardVal)}$`;

                    const time = Date.now() / 300;
                    const scale = 1 + Math.sin(time) * 0.05; 
                    const offset = Math.sin(time * 2) * 3; 

                    ctx.save();
                    ctx.translate(btn.x, btn.y - btn.r * 1.2 + offset); 
                    ctx.scale(scale, scale);

                    ctx.font = `bold ${btn.r * 0.4}px "Arial Black"`;
                    const metrics = ctx.measureText(rewardText);
                    const padX = 10;
                    const padY = 4;
                    const badgeW = metrics.width + (padX * 2);
                    const badgeH = (btn.r * 0.4) + (padY * 2);

                    ctx.fillStyle = '#00AA00'; 
                    ctx.beginPath();
                    ctx.roundRect(-badgeW/2, -badgeH/2, badgeW, badgeH, 10);
                    ctx.fill();
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    ctx.fillStyle = '#FFFFFF';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(rewardText, 0, 0);

                    ctx.restore();
                } 
                else if(btn.id === 'settings') {
                    ctx.fillStyle = '#777'; ctx.beginPath(); ctx.arc(btn.x, btn.y, btn.r, 0, Math.PI*2); ctx.fill();
                    ctx.strokeStyle = '#FFF'; ctx.lineWidth = 2; ctx.stroke();
                    ctx.save(); ctx.translate(btn.x, btn.y);
                    ctx.fillStyle = '#DDD'; ctx.beginPath(); ctx.arc(0,0,btn.r*0.5,0,Math.PI*2); ctx.fill();
                    for(let i=0; i<8; i++) { ctx.rotate(Math.PI/4); ctx.fillRect(btn.r*0.5, -btn.r*0.15, btn.r*0.3, btn.r*0.3); }
                    ctx.restore();
                }
                else if(btn.id === 'mute') {
                    ctx.fillStyle = '#444'; ctx.beginPath(); ctx.arc(btn.x, btn.y, btn.r, 0, Math.PI*2); ctx.fill();
                    ctx.strokeStyle = '#FFF'; ctx.lineWidth = 1; ctx.stroke();
                    drawStrokedText(soundManager.muted ? "üîá" : "üîä", btn.x, btn.y+2, btn.r, '#FFF');
                }
                else if(btn.id === 'lang') {
                    ctx.fillStyle = '#4488FF'; ctx.beginPath(); ctx.arc(btn.x, btn.y, btn.r, 0, Math.PI*2); ctx.fill();
                    ctx.strokeStyle = '#FFF'; ctx.lineWidth = 1; ctx.stroke();
                    drawStrokedText(gameState.lang.toUpperCase(), btn.x, btn.y+2, btn.r * 0.7, '#FFF');
                }
            });
        }
        
        renderState.floatingTexts.forEach(ft => { 
            ft.y -= ft.vy; ft.life -= 0.02; 
            ctx.globalAlpha = Math.max(0, ft.life); 
            drawStrokedText(ft.text, ft.x, ft.y, ft.size, ft.color);
            ctx.globalAlpha = 1; 
        }); 
        renderState.floatingTexts = renderState.floatingTexts.filter(ft => ft.life > 0);
        
        renderState.effects.forEach(fx => { fx.life--; ctx.globalAlpha = fx.life/20; ctx.fillStyle=fx.color; ctx.beginPath(); ctx.arc(fx.x, fx.y, 40*(1-fx.life/40), 0, Math.PI*2); ctx.fill(); ctx.globalAlpha=1; }); renderState.effects = renderState.effects.filter(fx => fx.life > 0);
    }
    
    function drawCharacter(ctx, x, y, size, level) {
        const color = getUnitColor(level);
        
        if (level >= 30) {
            ctx.save();
            const time = Date.now() / 500;
            ctx.translate(0, 0); 
            ctx.rotate(time);
            ctx.globalAlpha = 0.4;
            ctx.fillStyle = color;
            for(let i=0; i<3; i++) {
                ctx.rotate((Math.PI * 2) / 3);
                ctx.beginPath();
                ctx.arc(0, size * 0.6, size * 0.1, 0, Math.PI*2);
                ctx.fill();
            }
            ctx.restore();
        }

        if (level >= 40) {
             ctx.save();
             ctx.shadowBlur = 20;
             ctx.shadowColor = color;
             ctx.strokeStyle = '#FFF';
             ctx.lineWidth = 3;
             ctx.beginPath();
             ctx.moveTo(-size*0.3, -size*0.2);
             ctx.quadraticCurveTo(-size*0.8, -size*0.6, -size*0.4, -size*0.8);
             ctx.quadraticCurveTo(-size*0.2, -size*0.6, -size*0.3, -size*0.2);
             ctx.moveTo(size*0.3, -size*0.2);
             ctx.quadraticCurveTo(size*0.8, -size*0.6, size*0.4, -size*0.8);
             ctx.quadraticCurveTo(size*0.2, -size*0.6, size*0.3, -size*0.2);
             ctx.stroke();
             ctx.restore();
        }

        ctx.fillStyle = color; 
        ctx.strokeStyle = '#000'; 
        ctx.lineWidth = 2;
        
        ctx.beginPath();
        ctx.roundRect(-size*0.5, -size*0.1, size*0.15, size*0.4, 5);
        ctx.fill(); ctx.stroke();

        ctx.beginPath(); 
        ctx.roundRect(-size*0.4, -size*0.2, size*0.8, size*0.7, size*0.2); 
        ctx.fill(); ctx.stroke();
        
        ctx.fillStyle = '#75D5E6'; 
        ctx.beginPath(); 
        ctx.ellipse(size*0.15, -size*0.05, size*0.25, size*0.15, 0, 0, Math.PI*2); 
        ctx.fill(); ctx.stroke();
        
        ctx.fillStyle = 'rgba(255,255,255,0.8)';
        ctx.beginPath();
        ctx.ellipse(size*0.25, -size*0.1, size*0.08, size*0.04, 0, 0, Math.PI*2);
        ctx.fill();

        if (level >= 10) {
            ctx.save();
            ctx.translate(0, -size*0.2); 
            const hatType = level % 3;
            
            if (hatType === 0) { 
                ctx.fillStyle = '#FFD700'; ctx.strokeStyle = '#000';
                ctx.beginPath();
                ctx.moveTo(-size*0.25, 0);
                ctx.lineTo(-size*0.25, -size*0.25);
                ctx.lineTo(-size*0.1, -size*0.15);
                ctx.lineTo(0, -size*0.3);
                ctx.lineTo(size*0.1, -size*0.15);
                ctx.lineTo(size*0.25, -size*0.25);
                ctx.lineTo(size*0.25, 0);
                ctx.closePath();
                ctx.fill(); ctx.stroke();
            } else if (hatType === 1) { 
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(0, 0, size*0.26, Math.PI, 0);
                ctx.fillRect(0, -size*0.05, size*0.4, size*0.05); 
                ctx.fill(); ctx.stroke();
            } else { 
                ctx.fillStyle = '#FFF';
                ctx.beginPath();
                ctx.moveTo(-size*0.2, 0); ctx.lineTo(-size*0.3, -size*0.25); ctx.lineTo(-size*0.1, 0);
                ctx.moveTo(size*0.2, 0); ctx.lineTo(size*0.3, -size*0.25); ctx.lineTo(size*0.1, 0);
                ctx.fill(); ctx.stroke();
            }
            ctx.restore();
        }

        if (level >= 20) {
            ctx.save();
            const gearType = level % 2;
            if (gearType === 0) { 
                 ctx.translate(-size*0.5, size*0.1);
                 ctx.rotate(-Math.PI/4);
                 ctx.fillStyle = '#AAA'; ctx.fillRect(0, -2, size*0.6, 4);
                 ctx.fillStyle = '#654'; ctx.fillRect(-10, -4, 10, 8);
                 ctx.strokeRect(0, -2, size*0.6, 4);
            } else { 
                 ctx.translate(-size*0.4, size*0.1);
                 ctx.fillStyle = '#800000';
                 ctx.beginPath();
                 ctx.arc(0,0, size*0.2, 0, Math.PI*2);
                 ctx.fill(); ctx.stroke();
                 ctx.fillStyle = '#FFD700';
                 ctx.beginPath();
                 ctx.arc(0,0, size*0.08, 0, Math.PI*2);
                 ctx.fill();
            }
            ctx.restore();
        }
    }

    // --- NEW ROBUST INPUT HANDLER ---
    
    // Get mouse/touch position relative to canvas content
    function getEventPos(canvas, e) {
        const rect = canvas.getBoundingClientRect();
        const clientX = (e.touches && e.touches.length > 0) ? e.touches[0].clientX : e.clientX;
        const clientY = (e.touches && e.touches.length > 0) ? e.touches[0].clientY : e.clientY;
        
        // Safety for empty touches array on touchend
        if (clientX === undefined) return { x: 0, y: 0 }; // Fallback

        // Map CSS coordinates to Canvas Logic Coordinates
        // Since logic uses window.innerWidth/Height and canvas css matches it,
        // and ctx.scale handles DPR, we just need the relative CSS position.
        return {
            x: clientX - rect.left,
            y: clientY - rect.top
        };
    }

    let dragTarget=null, dragSX=0, dragSY=0, dragOX=0, dragOY=0;
    
    function handleInputStart(e) {
        // Normalize coordinates
        const pos = getEventPos(canvas, e);
        const x = pos.x;
        const y = pos.y;

        // Visual Feedback for debugging (White ripple)
        renderState.effects.push({x: x, y: y, life: 10, color: 'rgba(255, 255, 255, 0.5)'});

        soundManager.checkContext();
        if (gameState.paused) {
            gameState.paused = false;
            if(soundManager.ctx && soundManager.ctx.state === 'suspended') {
                try { soundManager.ctx.resume(); } catch(e){}
            }
        }

        // Safety fallback
        if (!gameState.mode) gameState.mode = 'MERGE';
        
        if (gameState.mode !== 'MERGE') return;
        
        // Force settings visibility update just in case
        const muteBtn = renderState.uiButtons.find(b => b.id === 'mute');
        const langBtn = renderState.uiButtons.find(b => b.id === 'lang');
        if(muteBtn) muteBtn.visible = gameState.settingsOpen;
        if(langBtn) langBtn.visible = gameState.settingsOpen;

        // 1. Check UI Buttons (Priority)
        for (let btn of renderState.uiButtons) {
            if (!btn.visible) continue;
            
            // Increased hit radius by 20% for easier touching
            const hitRadius = btn.r * 1.2;

            if (Math.hypot(x - btn.x, y - btn.y) <= hitRadius) {
                soundManager.playClick();
                
                if(btn.id === 'settings') {
                    gameState.settingsOpen = !gameState.settingsOpen;
                    // Re-update visibility immediately for next frame
                    const m = renderState.uiButtons.find(b => b.id === 'mute');
                    const l = renderState.uiButtons.find(b => b.id === 'lang');
                    if(m) m.visible = gameState.settingsOpen;
                    if(l) l.visible = gameState.settingsOpen;
                }
                else if(btn.id==='buy') spawnUnit();
                else if(btn.id==='ad') {
                    yandexManager.showRewarded(() => { 
                        const r = getAdRewardAmount();
                        gameState.coins += r; 
                        spawnFloatingText(canvas.width/2/window.devicePixelRatio, canvas.height/2/window.devicePixelRatio, `+${formatNumber(r)}$`, '#FFD700', 30); 
                        soundManager.playWin(); 
                        saveGame(); 
                    });
                }
                else if(btn.id==='mute') soundManager.setMute(!soundManager.muted);
                else if(btn.id==='lang') { gameState.lang = gameState.lang === 'ru' ? 'en' : 'ru'; updateDomTexts(); }
                return; // Stop checking if button hit
            }
        }
        
        // 2. Check Units (Reverse order for Z-index)
        for (let i = gameState.units.length - 1; i >= 0; i--) { 
            const u = gameState.units[i]; 
            // Safety check for unit position
            if (u.x === undefined || u.y === undefined) continue;

            if (Math.hypot(x - u.x, y - u.y) < (CONFIG.slotSize/2 + 10)) { 
                dragTarget=u; 
                dragTarget.isDragging=false; 
                dragSX=x; 
                dragSY=y; 
                dragOX=x-u.x; 
                dragOY=y-u.y; 
                // Reorder for rendering on top
                gameState.units.splice(i, 1); 
                gameState.units.push(u); 
                return; 
            } 
        }
    }

    function handleInputMove(e) { 
        if (dragTarget && gameState.mode === 'MERGE') { 
            const pos = getEventPos(canvas, e);
            dragTarget.x = pos.x - dragOX; 
            dragTarget.y = pos.y - dragOY; 
            if (!dragTarget.isDragging && Math.hypot(pos.x - dragSX, pos.y - dragSY) > 5) {
                dragTarget.isDragging = true; 
            }
        } 
    }

    function handleInputEnd(e) {
        if (dragTarget) {
            // End coordinates are tricky in touchend, use last known or drag target pos
            // For click logic, we rely on start position vs current position
            // But 'e' in touchend has no coordinates for the ended touch.
            // We use the dragTarget.x/y which updated in Move.
            
            // Re-calculate visual position based on dragTarget.x
            // Or calculate simple distance if it was a tap
            
            const wasTap = !dragTarget.isDragging;

            if (wasTap) {
                let inc = getClickIncome(dragTarget.level); 
                const isCrit = Math.random() < 0.15;
                if(isCrit) { inc *= 5; soundManager.playHit(); } else soundManager.playClick(); 
                gameState.coins += inc;
                
                const t = TRANSLATION[gameState.lang] || TRANSLATION.en;
                const text = `${isCrit ? t.CRIT + ' ' : ''}+${formatNumber(inc)}$`;
                spawnFloatingText(dragTarget.x, dragTarget.y - 30, text, isCrit?'#FF4500':'#4CAF50', isCrit?24:16); 
                
                dragTarget.animScale = 0.8; 
                ret(dragTarget);
            } else {
                dragTarget.isDragging = false; 
                // Find slot at dropped position
                const realSlot = renderState.slots.find(s => 
                    dragTarget.x >= s.x && 
                    dragTarget.x <= s.x + s.width && 
                    dragTarget.y >= s.y && 
                    dragTarget.y <= s.y + s.height
                );

                if (realSlot) {
                    const target = gameState.units.find(u => u.slotIndex === realSlot.index && u.id !== dragTarget.id);
                    if (target && target.level === dragTarget.level) {
                        if (target.level >= 50) {
                            spawnFloatingText(dragTarget.x, dragTarget.y, TRANSLATION[gameState.lang].MAX_LVL, '#F00');
                            ret(dragTarget); 
                        } else {
                            const newLvl = target.level + 1; 
                            if(newLvl > gameState.maxLevel) gameState.maxLevel = newLvl;
                            renderState.effects.push({x: realSlot.x + realSlot.width/2, y: realSlot.y + realSlot.height/2, life: 20, color: '#FFF'});
                            gameState.units = gameState.units.filter(u => u.id !== dragTarget.id && u.id !== target.id);
                            gameState.units.push({id: Date.now(), level: newLvl, slotIndex: realSlot.index, x: realSlot.x+realSlot.width/2, y: realSlot.y+realSlot.height/2, isDragging: false, animScale: 0.1});
                            soundManager.playMerge(); 
                            saveGame();
                        }
                    } else if (!target) { 
                        dragTarget.slotIndex = realSlot.index; 
                        snap(dragTarget, realSlot); 
                        saveGame(); 
                    } else {
                        ret(dragTarget);
                    }
                } else {
                    ret(dragTarget);
                }
            }
            dragTarget = null;
        }
    }

    // Attach Robust Listeners
    canvas.addEventListener('mousedown', handleInputStart);
    window.addEventListener('mousemove', handleInputMove);
    window.addEventListener('mouseup', handleInputEnd);

    canvas.addEventListener('touchstart', (e) => {
        // e.preventDefault(); // Stop mouse emulation - handled globally in body? 
        // We set passive: false to allow preventDefault if needed, but for UI feedback let's just run logic.
        // Actually, preventing default on canvas is good to stop scrolling.
        if(e.cancelable) e.preventDefault();
        handleInputStart(e);
    }, {passive: false});

    canvas.addEventListener('touchmove', (e) => {
        if(e.cancelable) e.preventDefault();
        handleInputMove(e);
    }, {passive: false});

    canvas.addEventListener('touchend', (e) => {
        if(e.cancelable) e.preventDefault();
        handleInputEnd(e);
    }, {passive: false});


    function snap(u, s) { u.x=s.x+s.width/2; u.y=s.y+s.height/2; }
    function ret(u) { const s = renderState.slots.find(sl=>sl.index === u.slotIndex); if(s) snap(u, s); }
    function spawnFloatingText(x, y, text, color, size=20) { renderState.floatingTexts.push({x, y, text, color, size, life: 1.0, vy: 2}); }
    
    function spawnUnit() {
        const s = getSmartShopState(); const cost = getBuyCost(s.level);
        if (gameState.coins >= cost) {
            const occ = gameState.units.map(u=>u.slotIndex); const free = renderState.slots.filter(s=>!occ.includes(s.index));
            if(free.length) { gameState.coins -= cost; const sl = free[Math.floor(Math.random()*free.length)]; gameState.units.push({id: Date.now()+Math.random(), level: s.level, slotIndex: sl.index, x: sl.x+sl.width/2, y: sl.y+sl.height/2, isDragging: false, animScale: 0.1}); soundManager.playBuy(); saveGame(); }
        } else {
            // Show NO MONEY toast
            const w = canvas.width / window.devicePixelRatio;
            const h = canvas.height / window.devicePixelRatio;
            const msg = TRANSLATION[gameState.lang] ? TRANSLATION[gameState.lang].NO_MONEY : "No Money";
            spawnFloatingText(w / 2, h / 2, msg, '#FF5555', 24);
        }
    }

    function updateDomTexts() {
        const t = TRANSLATION[gameState.lang] || TRANSLATION.en;
        
        const elLoad = document.getElementById('loadingText'); if(elLoad) elLoad.innerText = t.LOADING;
        const elChal = document.getElementById('chalTitle'); if(elChal) elChal.innerText = t.CHALLENGE;
        const elAcc = document.getElementById('btnAccept'); if(elAcc) elAcc.innerText = t.ACCEPT;
        const elDec = document.getElementById('btnDecline'); if(elDec) elDec.innerText = t.DECLINE;
        const elSet = document.getElementById('setupTitle'); if(elSet) elSet.innerText = t.PREPARE;
        const elSq = document.getElementById('squadTitle'); if(elSq) elSq.innerText = t.SQUAD;
        const elEn = document.getElementById('enemyTitle'); if(elEn) elEn.innerText = t.ENEMY;
        
        const hiddenLabel = document.getElementById('hiddenLabel');
        if(hiddenLabel) hiddenLabel.innerText = t.HIDDEN;
        
        const elFi = document.getElementById('fightBtn'); if(elFi) elFi.innerText = t.FIGHT_BTN;
        const elFa = document.getElementById('fallenTitle'); if(elFa) elFa.innerText = t.FALLEN;
        const elCo = document.getElementById('continueBtn'); if(elCo) elCo.innerText = t.CONTINUE;
        
        const rotateMsg = document.getElementById('rotateMsg');
        if(rotateMsg) rotateMsg.innerText = t.ROTATE;

        const squadPowerLabel = document.getElementById('squadPowerLabel');
        if(squadPowerLabel) squadPowerLabel.innerText = t.POWER;
        
        const enemyPowerLabel = document.getElementById('enemyPowerLabel');
        if(enemyPowerLabel) enemyPowerLabel.innerText = t.POWER;
    }

    function saveGame() { localStorage.setItem('amg_save', JSON.stringify({ coins: gameState.coins, maxLevel: gameState.maxLevel, units: gameState.units.map(u => ({level: u.level, slotIndex: u.slotIndex})) })); }
    function loadGame() { try { const d = JSON.parse(localStorage.getItem('amg_save')); if(d) { gameState.coins=d.coins||0; gameState.maxLevel=d.maxLevel||1; gameState.units=(d.units||[]).map(u=>({id:Date.now()+Math.random(), level:u.level, slotIndex:u.slotIndex, x:0, y:0, isDragging:false, animScale:1})); } } catch(e){} }

    if (!CanvasRenderingContext2D.prototype.roundRect) { CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) { if (w<2*r) r=w/2; if(h<2*r) r=h/2; this.beginPath(); this.moveTo(x+r, y); this.arcTo(x+w, y, x+w, y+h, r); this.arcTo(x+w, y+h, x, y+h, r); this.arcTo(x+w, y+h, x, y+h, r); this.arcTo(x, y+h, x, y, r); this.arcTo(x, y, x+w, y, r); this.closePath(); return this; }; }

    // --- MAIN INITIALIZATION SEQUENCE ---
    window.onload = async () => {
        await yandexManager.init();
        loadGame();
        if(!gameState.units.length) gameState.units.push({id:Date.now(),level:1,slotIndex:0,x:0,y:0,isDragging:false,animScale:1});
        
        window.addEventListener('resize', resize);
        resize(); // Initial smart layout calc
        updateDomTexts();
        
        document.getElementById('loadingOverlay').style.display = 'none';
        yandexManager.notifyGameReady();
        yandexManager.gameplayStart();
        requestAnimationFrame(gameLoop);
    };
</script>
</body>
</html>
