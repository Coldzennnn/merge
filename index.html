<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Among Us Merge: Final Release</title>

    <script src="/sdk.js"></script>

    <style>
        /* 1. GLOBAL RESET & MOBILE OPTIMIZATION */
        * {
            box-sizing: border-box;
            outline: none;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            touch-action: none;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            overflow: hidden;
            font-family: 'Arial Black', 'Verdana', sans-serif;
            overscroll-behavior: none;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        /* --- UI OVERLAYS --- */
        .overlay {
            display: none;
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 100;
            align-items: center;
            justify-content: center;
            color: white;
            flex-direction: column;
        }

        /* Rotate Overlay (New) */
        #rotateOverlay {
            background: rgba(0, 0, 0, 0.95);
            z-index: 99999;
        }

        .phone-icon {
            width: 60px;
            height: 100px;
            border: 4px solid #FFA500;
            border-radius: 10px;
            margin-bottom: 30px;
            position: relative;
            animation: rotateIcon 2.5s infinite ease-in-out;
        }
        .phone-icon::after {
            content: '';
            position: absolute;
            top: 5px; left: 50%; transform: translateX(-50%);
            width: 40px; height: 2px; background: #FFA500;
        }

        @keyframes rotateIcon {
            0% { transform: rotate(0deg); opacity: 1; }
            40% { transform: rotate(90deg); opacity: 1; }
            80% { transform: rotate(90deg); opacity: 0; }
            100% { transform: rotate(0deg); opacity: 0; }
        }

        #rotateMsg {
            font-family: 'Arial Black', sans-serif;
            font-size: 20px;
            color: white;
            text-align: center;
            padding: 0 20px;
            text-transform: uppercase;
        }

        /* Loading Screen */
        #loadingOverlay {
            z-index: 9999;
            background: #000;
            display: flex;
        }

        /* Popup Styles - Responsive using CSS Clamp */
        .popup-box {
            position: relative;
            width: clamp(280px, 80vw, 400px);
            background: #222;
            border: 3px solid #FFA500;
            border-radius: 15px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            box-shadow: 0 0 30px rgba(255, 165, 0, 0.5);
        }

        .challenge-title { font-family: 'Arial Black', sans-serif; font-size: clamp(20px, 5vw, 30px); color: #FFA500; text-transform: uppercase; letter-spacing: 2px; text-align: center; -webkit-text-stroke: 1px black; margin-bottom: 15px; }
        .enemy-avatar-placeholder { width: 80px; height: 80px; background: #500; border-radius: 50%; margin-bottom: 10px; border: 2px solid #F00; display: flex; align-items: center; justify-content: center; font-size: 40px; }
        .enemy-name { font-size: 20px; font-weight: bold; margin-bottom: 20px; color: #FFF; }
        .btn-group { display: flex; gap: 10px; width: 100%; }
        
        button { font-family: inherit; }

        .btn-accept { flex: 1; padding: 10px; border: none; border-radius: 5px; background: #00AA00; color: white; font-weight: bold; cursor: pointer; text-transform: uppercase; border: 2px solid #005500; }
        .btn-decline { flex: 1; padding: 10px; border: none; border-radius: 5px; background: #555; color: #AAA; font-weight: bold; cursor: pointer; text-transform: uppercase; border: 2px solid #333; }

        /* Setup & Battle UI - REFACTORED FOR RESPONSIVENESS */
        .battle-header { 
            font-family: 'Arial Black', sans-serif; 
            font-size: clamp(20px, 5vw, 40px); 
            color: #FFA500; 
            text-transform: uppercase; 
            margin-bottom: 10px; 
            text-shadow: 2px 2px 0 #000; 
            text-align: center; 
            flex-shrink: 0;
        }
        .setup-arena { 
            display: flex; 
            width: 95%; 
            max-width: 800px; 
            height: 60vh; /* Responsive Height */
            max-height: 500px;
            border: 2px solid #444; 
            background: #222; 
            border-radius: 10px; 
            overflow: hidden; 
            margin-bottom: 20px; 
            flex-direction: row; /* Force row layout */
        }
        .side { 
            flex: 1; 
            padding: 5px; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            overflow-y: auto; /* Scrollable list */
            overflow-x: hidden;
        }
        .side.enemy { background: #2C0000; border-left: 2px solid #444; }
        .side.player { background: #111; }
        .side-title { font-size: clamp(14px, 4vw, 18px); margin-bottom: 10px; color: #AAA; text-align: center; font-weight: bold; text-shadow: 1px 1px 0 #000; }

        .unit-card { 
            width: clamp(50px, 12vw, 80px); 
            height: clamp(70px, 16vw, 100px); 
            background: #333; 
            margin: 3px; 
            border-radius: 8px; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center; 
            border: 2px solid transparent; 
            cursor: pointer; 
            position: relative; 
            flex-shrink: 0;
        }
        .unit-card.selected { border-color: #00FF00; background: #003300; box-shadow: 0 0 10px #00FF00; }
        .unit-card.mystery { background: #1a1a1a; border: 2px dashed #555; color: #555; font-size: 30px; font-weight: bold; cursor: default; }
        .unit-body { width: 50%; height: 50%; border-radius: 10px; border: 2px solid black; position: relative; margin-bottom: 5px; }
        .unit-visor { width: 70%; height: 40%; background: #75D5E6; border-radius: 50%; position: absolute; top: 20%; left: 50%; transform: translateX(-50%); border: 1px solid black; }

        .action-btn { padding: 15px 40px; font-size: 24px; background: #FF0000; color: white; border: 2px solid #500; border-radius: 5px; cursor: pointer; text-transform: uppercase; font-weight: bold; box-shadow: 0 4px 0 #500; }
        .action-btn:active { box-shadow: 0 2px 0 #500; transform: translateY(2px); }
        .action-btn:disabled { background: #555; border-color: #333; box-shadow: none; cursor: not-allowed; opacity: 0.5; transform: none; }

        /* Media Query for Landscape Mobile / Short Screens */
        @media (max-height: 500px) {
            .setup-arena { height: 50vh; margin-bottom: 10px; }
            .unit-card { transform: scale(0.85); margin: 1px; }
            .battle-header { font-size: 20px; margin-bottom: 5px; }
            .action-btn { padding: 8px 30px; font-size: 18px; }
        }

        #playerSquadList, #enemyContainer { display: flex; flex-wrap: wrap; justify-content: center; width: 100%; align-content: flex-start; }

        /* Result */
        .result-title { font-family: 'Arial Black', sans-serif; font-size: 40px; margin-bottom: 20px; -webkit-text-stroke: 2px black; letter-spacing: 2px; }
        .win { color: #00FF00; } .lose { color: #FF0000; }
        .dead-list { color: #FF5555; margin-top: 10px; font-size: 14px; font-weight: bold; text-shadow: 1px 1px 0 #000; }
    </style>
</head>
<body oncontextmenu="return false;" ondragstart="return false;">

    <canvas id="gameCanvas"></canvas>

    <!-- NEW ROTATE OVERLAY -->
    <div id="rotateOverlay" class="overlay">
        <div class="phone-icon"></div>
        <div id="rotateMsg">Please rotate your device</div>
    </div>

    <div id="loadingOverlay" class="overlay">
        <h1 style="color: #666; font-size: 24px; font-family: 'Arial Black';">LOADING...</h1>
    </div>

    <div id="challengeOverlay" class="overlay">
        <div class="popup-box">
            <div class="challenge-title" id="chalTitle">FAIR FIGHT!</div>
            <div class="enemy-avatar-placeholder">‚öîÔ∏è</div>
            <div class="enemy-name" id="chalName">PlayerName</div>
            <div class="btn-group">
                <button class="btn-decline" id="btnDecline">Decline</button>
                <button class="btn-accept" id="btnAccept">Accept</button>
            </div>
        </div>
    </div>

    <div id="battleSetupOverlay" class="overlay">
        <div class="battle-header" id="setupTitle">PREPARE SQUAD</div>
        <div class="setup-arena">
            <div class="side player">
                <div class="side-title"><span id="squadTitle">Your Squad</span> <span id="squadCount" style="color:#0F0">(0/5)</span></div>
                <div id="playerSquadList"></div>
                <div style="margin-top:10px; font-size: 14px; color: #8F8; font-weight: bold; text-shadow: 1px 1px 0 #000;">Power: <span id="squadPower">0</span></div>
            </div>
            <div class="side enemy">
                <div class="side-title" id="enemyTitle">Hidden Enemy</div>
                <div style="color: #FF5555; font-size: 12px; margin-bottom: 5px; letter-spacing: 1px; font-weight: bold;">OPPONENT HIDDEN</div>
                <div id="enemyContainer"></div>
                <div style="margin-top:10px; font-size: 14px; color: #F88; font-weight: bold; text-shadow: 1px 1px 0 #000;">Power: <span id="enemyPower">???</span></div>
            </div>
        </div>
        <button class="action-btn" id="fightBtn" disabled>FIGHT</button>
    </div>

    <div id="battleResultOverlay" class="overlay">
        <div class="result-title" id="resultTitle">VICTORY</div>
        <div id="resultReward" style="font-size: 28px; color: gold; margin-bottom: 20px; font-family: 'Arial Black'; -webkit-text-stroke: 1.5px black;"></div>
        <div id="deadHeroesBlock" style="display:none; margin-bottom: 20px;">
            <div style="color: #AAA;" id="fallenTitle">Fallen Heroes:</div>
            <div class="dead-list" id="deadListText"></div>
        </div>
        <button class="action-btn" id="continueBtn" style="background:#4CAF50; border-color: #2E7D32; box-shadow: 0 4px 0 #2E7D32;">CONTINUE</button>
    </div>

<script>
    // 1. INPUT BLOCKING & UTILS
    window.addEventListener('contextmenu', e => { e.preventDefault(); return false; }, { passive: false });
    window.addEventListener('selectstart', e => { e.preventDefault(); return false; }, { passive: false });
    window.addEventListener('dragstart', e => { e.preventDefault(); return false; }, { passive: false });
    document.addEventListener('touchstart', e => {
        if (e.target.closest('button') || e.target.closest('.unit-card')) return;
        if (!e.target.closest('.overlay') && e.target.tagName !== 'CANVAS') e.preventDefault(); 
    }, { passive: false });

    // 2. AUDIO SYSTEM
    class SoundManager {
        constructor() {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            this.masterGain = this.ctx.createGain();
            this.masterGain.connect(this.ctx.destination);
            this.muted = localStorage.getItem('amg-mute') === 'true';
            this.wasMutedBeforeAd = false;
            this.updateGain();
        }
        setMute(isMuted) {
            this.muted = isMuted; localStorage.setItem('amg-mute', isMuted); this.updateGain();
            if (this.ctx.state === 'suspended' && !this.muted) this.ctx.resume();
            return this.muted;
        }
        muteForAd() { this.wasMutedBeforeAd = this.muted; if (!this.muted && this.ctx) this.ctx.suspend(); }
        unmuteFromAd() { if (!this.wasMutedBeforeAd && this.ctx) this.ctx.resume(); }
        updateGain() { this.masterGain.gain.setValueAtTime(this.muted ? 0 : 0.3, this.ctx.currentTime); }
        checkContext() { if (this.ctx.state === 'suspended') this.ctx.resume(); }
        
        _playTone(freq, type, duration, volDecibels, slide = false, slideFreq = 0) {
            this.checkContext();
            const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
            osc.type = type; osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
            if (slide) { const target = slideFreq || freq * 0.2; osc.frequency.exponentialRampToValueAtTime(Math.max(10, target), this.ctx.currentTime + duration); } 
            else if (slideFreq) { osc.frequency.linearRampToValueAtTime(slideFreq, this.ctx.currentTime + duration); }
            const vol = Math.pow(10, volDecibels / 20);
            gain.gain.setValueAtTime(vol, this.ctx.currentTime); gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
            osc.connect(gain); gain.connect(this.masterGain); osc.start(); osc.stop(this.ctx.currentTime + duration);
        }
        
        playClick() { if (this.muted) return; this._playTone(800, 'sine', 0.1, -10, true); }
        playMerge() { if (this.muted) return; this._playTone(300, 'triangle', 0.3, -5, false, 800); }
        playBuy() { if (this.muted) return; this._playTone(1200, 'square', 0.1, -12); setTimeout(() => this._playTone(1600, 'square', 0.15, -12), 80); }
        playAttack() { if (this.muted) return; this._playTone(400, 'sawtooth', 0.15, -10, true, 50); }
        playHit() { if (this.muted) return; this._playTone(150, 'square', 0.1, -5, true, 10); }
        playWin() { if (this.muted) return; this._playTone(523, 'sine', 0.2, -8); setTimeout(() => this._playTone(659, 'sine', 0.2, -8), 200); setTimeout(() => this._playTone(783, 'sine', 0.4, -8), 400); }
        playLose() { if (this.muted) return; this._playTone(300, 'sawtooth', 0.3, -5, true, 50); }
    }

    // 3. YANDEX SDK MANAGER
    class YandexManager {
        constructor() { this.ysdk = null; this.lang = 'en'; this.isMock = false; }

        async init() {
            const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error("SDK Timeout")), 2000));
            const sdkPromise = new Promise(async (resolve, reject) => {
                 if (window.YaGames) { try { resolve(await window.YaGames.init()); } catch (e) { reject(e); } } 
                 else {
                     let tries = 0;
                     const i = setInterval(async () => {
                        tries++;
                        if (window.YaGames) { clearInterval(i); resolve(await window.YaGames.init()); }
                        if (tries > 20) { clearInterval(i); reject(new Error("No SDK script")); }
                     }, 100);
                 }
            });

            try {
                this.ysdk = await Promise.race([sdkPromise, timeoutPromise]);
                const urlParams = new URLSearchParams(window.location.search);
                const urlLang = urlParams.get('lang');
                const envLang = this.ysdk.environment.i18n.lang;
                this.lang = ['ru', 'be', 'kk', 'uk', 'uz'].includes(urlLang || envLang) ? 'ru' : 'en';
            } catch (e) {
                console.warn("SDK Failed. Mock Mode.");
                this.isMock = true; this.lang = 'ru';
            }
            gameState.lang = this.lang;
        }

        notifyGameReady() {
            if (this.ysdk && this.ysdk.features.LoadingAPI) {
                this.ysdk.features.LoadingAPI.ready();
            }
        }

        gameplayStart() { if (this.ysdk && this.ysdk.features.GameplayAPI) this.ysdk.features.GameplayAPI.start(); }
        gameplayStop() { if (this.ysdk && this.ysdk.features.GameplayAPI) this.ysdk.features.GameplayAPI.stop(); }

        showInterstitial(cb) {
            if (this.isMock) { if(cb) cb(); return; }
            this.gameplayStop();
            this.ysdk.adv.showFullscreenAdv({ 
                callbacks: { 
                    onOpen: () => { soundManager.muteForAd(); },
                    onClose: () => { soundManager.unmuteFromAd(); this.gameplayStart(); if (cb) cb(); }, 
                    onError: () => { soundManager.unmuteFromAd(); this.gameplayStart(); if (cb) cb(); } 
                } 
            });
        }

        showRewarded(onReward) {
            if (this.isMock) { onReward(); return; }
            this.gameplayStop();
            this.ysdk.adv.showRewardedVideo({
                callbacks: {
                    onOpen: () => { soundManager.muteForAd(); },
                    onRewarded: () => { onReward(); },
                    onClose: () => { soundManager.unmuteFromAd(); this.gameplayStart(); },
                    onError: () => { soundManager.unmuteFromAd(); this.gameplayStart(); }
                }
            });
        }
    }

    // 4. GAME LOGIC & CONFIG
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const soundManager = new SoundManager();
    const yandexManager = new YandexManager();

    const CONFIG = {
        gridRows: 3, gridCols: 5, slotSize: 0, slotMargin: 10,
        BASE_INCOME: 2, INCOME_MULTIPLIER: 2.1,
        BASE_COST: 60, PRICE_MULTIPLIER: 2.3,
        HP_BASE: 80, HP_MULT: 1.4,
        DMG_BASE: 12, DMG_MULT: 1.35,
        BATTLE_INTERVAL_MIN: 45, SQUAD_LIMIT: 5,
        UNIT_COLORS: ['#FF0000', '#0000FF', '#008000', '#FFFF00', '#FFA500', '#800080', '#00FFFF', '#FFC0CB', '#8B4513', '#333333'],
        gridColor: '#23272A'
    };
    
    // NEW LAYOUT SYSTEM
    const layout = {
        isPortrait: false,
        scale: 1,
        gridX: 0,
        gridY: 0,
        fontSize: 16
    };

    const NICKNAMES = ["Shadow", "Viper", "Ghost", "MadMax", "Cyber", "Wolf", "Storm", "Pro", "Speed", "Doom", "Alpha", "Venom", "Kratos", "Loki", "Zero"];
    const TRANSLATION = {
        ru: { 
            CHALLENGE: "–í–´–ó–û–í!", ACCEPT: "–ë–û–ô", DECLINE: "–°–ë–ï–ñ–ê–¢–¨", 
            PREPARE: "–í–´–ë–û–† –û–¢–†–Ø–î–ê", SQUAD: "–í–∞—à –æ—Ç—Ä—è–¥", ENEMY: "–í—Ä–∞–≥", 
            FIGHT: "–í –ê–¢–ê–ö–£", WIN: "–ü–û–ë–ï–î–ê!", LOSE: "–ü–û–†–ê–ñ–ï–ù–ò–ï", 
            FALLEN: "–ü–æ—Ç–µ—Ä–∏:", CONT: "–î–ê–õ–ï–ï", REWARD: "–ù–∞–≥—Ä–∞–¥–∞", 
            FREE_COINS: "–ú–æ–Ω–µ—Ç—ã", LVL: "–£—Ä.", 
            AD_BTN: "–†–µ–∫–ª–∞–º–∞",
            ROTATE_MSG: "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–µ—Ä–µ–≤–µ—Ä–Ω–∏—Ç–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ"
        },
        en: { 
            CHALLENGE: "CHALLENGE!", ACCEPT: "FIGHT", DECLINE: "FLEE", 
            PREPARE: "PREPARE SQUAD", SQUAD: "Your Squad", ENEMY: "Enemy", 
            FIGHT: "ATTACK", WIN: "VICTORY!", LOSE: "DEFEAT", 
            FALLEN: "Fallen:", CONT: "CONTINUE", REWARD: "Reward", 
            FREE_COINS: "Coins", LVL: "Lvl", 
            AD_BTN: "Ad",
            ROTATE_MSG: "Please rotate your device"
        }
    };

    let gameState = { mode: 'MERGE', coins: 0, units: [], maxLevel: 1, lang: 'en', challengeTimer: 60, enemySquad: [], selectedUnitIds: [], paused: false, settingsOpen: false };
    let battleState = { playerTeam: [], enemyTeam: [], projectiles: [], phase: 'INIT', phaseTimer: 0, deadUnitIds: [] };
    let renderState = { slots: [], effects: [], floatingTexts: [], uiButtons: [], stars: [] };

    // UTILS
    function getBuyCost(level) { return Math.floor(CONFIG.BASE_COST * Math.pow(CONFIG.PRICE_MULTIPLIER, level - 1)); }
    function getClickIncome(level) { return Math.floor(CONFIG.BASE_INCOME * Math.pow(CONFIG.INCOME_MULTIPLIER, level - 1)); }
    function getStats(level) { return { hp: Math.floor(CONFIG.HP_BASE * Math.pow(CONFIG.HP_MULT, level - 1)), dmg: Math.floor(CONFIG.DMG_BASE * Math.pow(CONFIG.DMG_MULT, level - 1)) }; }
    function calculatePower(level) { return 10 * Math.pow(2, level - 1); }
    function formatNumber(num) { if (num>=1000000) return (num/1000000).toFixed(1)+'M'; if(num>=1000) return (num/1000).toFixed(1)+'k'; return Math.floor(num).toString(); }
    function getUnitColor(level) { return CONFIG.UNIT_COLORS[(level - 1) % CONFIG.UNIT_COLORS.length]; }
    function getSmartShopState() {
        const targetLevel = Math.max(1, gameState.maxLevel - 3);
        const counts = {}; gameState.units.forEach(u => { counts[u.level] = (counts[u.level] || 0) + 1; });
        const levels = Object.keys(counts).map(Number).sort((a,b) => a - b);
        let minOddLevel = -1;
        for (let lvl of levels) { if (counts[lvl] % 2 !== 0) { minOddLevel = lvl; break; } }
        if (minOddLevel !== -1 && minOddLevel < targetLevel) return { level: minOddLevel, type: 'HELP' };
        return { level: targetLevel, type: 'STANDARD' };
    }

    // GAME LOOP
    let lastTime = 0;
    function gameLoop(ts) {
        if (!gameState.paused) {
            if (!lastTime) lastTime = ts; const dt = (ts - lastTime) / 1000; lastTime = ts;
            if (gameState.mode === 'MERGE') { gameState.challengeTimer -= dt; if (gameState.challengeTimer <= 0) openChallenge(); }
            else if (gameState.mode === 'BATTLE') { updateBattle(dt); }
            render();
        }
        requestAnimationFrame(gameLoop);
    }

    // --- LOGIC FUNCTIONS (Unchanged logic, just wrappers) ---
    function openChallenge() {
        gameState.mode = 'CHALLENGE';
        const name = NICKNAMES[Math.floor(Math.random() * NICKNAMES.length)];
        gameState.enemySquad = [];
        const roll = Math.random(); let count, levelBase;
        if (roll < 0.75) { count = Math.floor(Math.random() * 3) + 1; levelBase = gameState.maxLevel - 1; } 
        else { count = Math.floor(Math.random() * 2) + 4; levelBase = gameState.maxLevel; }
        for(let i=0; i<count; i++) gameState.enemySquad.push({ level: Math.max(1, levelBase) });
        updateDomTexts();
        document.getElementById('chalName').innerText = name;
        document.getElementById('challengeOverlay').style.display = 'flex';
    }
    document.getElementById('btnDecline').onclick = () => {
        if (Math.random() > 0.7) yandexManager.showInterstitial();
        gameState.challengeTimer = CONFIG.BATTLE_INTERVAL_MIN + Math.random() * 15;
        gameState.mode = 'MERGE';
        document.getElementById('challengeOverlay').style.display = 'none';
    };
    document.getElementById('btnAccept').onclick = () => { document.getElementById('challengeOverlay').style.display = 'none'; openSetup(); };

    function openSetup() {
        gameState.mode = 'SETUP'; gameState.selectedUnitIds = [];
        const sorted = [...gameState.units].sort((a,b) => b.level - a.level).slice(0, 5);
        gameState.selectedUnitIds = sorted.map(u => u.id);
        renderSetupUI(); document.getElementById('battleSetupOverlay').style.display = 'flex';
    }
    function renderSetupUI() {
        updateDomTexts();
        document.getElementById('squadCount').innerText = `(${gameState.selectedUnitIds.length}/${CONFIG.SQUAD_LIMIT})`;
        const enemyCont = document.getElementById('enemyContainer'); enemyCont.innerHTML = '';
        for(let i=0; i<5; i++) { const el = document.createElement('div'); el.className = 'unit-card mystery'; el.innerText = '?'; enemyCont.appendChild(el); }
        const list = document.getElementById('playerSquadList'); list.innerHTML = '';
        let playerTotalPower = 0;
        [...gameState.units].sort((a,b)=>b.level-a.level).forEach(u => {
            const el = document.createElement('div'); el.className = 'unit-card';
            if (gameState.selectedUnitIds.includes(u.id)) { el.classList.add('selected'); playerTotalPower += calculatePower(u.level); }
            if (!gameState.selectedUnitIds.includes(u.id) && gameState.selectedUnitIds.length >= CONFIG.SQUAD_LIMIT) el.style.opacity = '0.5';
            el.innerHTML = `<div class="unit-body" style="background:${getUnitColor(u.level)}"><div class="unit-visor"></div></div><div style="color:white;font-size:10px; font-weight:bold; -webkit-text-stroke: 0.5px black;">Lvl ${u.level}</div>`;
            el.onclick = () => {
                const idx = gameState.selectedUnitIds.indexOf(u.id);
                if(idx !== -1) gameState.selectedUnitIds.splice(idx, 1);
                else if (gameState.selectedUnitIds.length < CONFIG.SQUAD_LIMIT) gameState.selectedUnitIds.push(u.id);
                soundManager.playClick(); renderSetupUI(); 
            };
            list.appendChild(el);
        });
        document.getElementById('squadPower').innerText = playerTotalPower;
        document.getElementById('fightBtn').disabled = gameState.selectedUnitIds.length === 0;
    }
    document.getElementById('fightBtn').onclick = () => { if(gameState.selectedUnitIds.length > 0) { soundManager.playClick(); document.getElementById('battleSetupOverlay').style.display='none'; initBattleMode(); } };

    function initBattleMode() {
        gameState.mode = 'BATTLE'; 
        battleState.projectiles = []; 
        battleState.deadUnitIds = [];
        renderState.stars = []; 
        
        // Logical Canvas Dimensions
        const w = window.innerWidth;
        const h = window.innerHeight;

        // Dynamic Unit Size (15% height, max 80px)
        const unitSize = Math.min(80, h * 0.15);
        battleState.unitSize = unitSize;

        for(let i=0; i<50; i++) renderState.stars.push({x: Math.random()*w, y: Math.random()*h, size: Math.random()*2+1});
        
        // Calculate Dynamic Spacing
        const playerTeamSize = gameState.selectedUnitIds.length;
        const enemyTeamSize = gameState.enemySquad.length;
        
        const spacingY_P = h / (playerTeamSize + 1);
        const spacingY_E = h / (enemyTeamSize + 1);

        battleState.playerTeam = gameState.selectedUnitIds.map((id, i) => {
            const u = gameState.units.find(x => x.id === id); const s = getStats(u.level);
            return { 
                originalId: id, 
                level: u.level, 
                hp: s.hp, maxHp: s.hp, dmg: s.dmg, 
                x: w * 0.15, 
                y: (i + 1) * spacingY_P, 
                team: 'player' 
            };
        });
        battleState.enemyTeam = gameState.enemySquad.map((u, i) => {
            const s = getStats(u.level);
            return { 
                originalId: `enemy_${i}`, 
                level: u.level, 
                hp: s.hp, maxHp: s.hp, dmg: s.dmg, 
                x: w * 0.85, 
                y: (i + 1) * spacingY_E, 
                team: 'enemy' 
            };
        });
        
        battleState.phase = 'INIT'; 
        battleState.phaseTimer = 1.0; 
    }
    
    function updateBattle(dt) {
        for (let i = battleState.projectiles.length - 1; i >= 0; i--) {
            const p = battleState.projectiles[i];
            const dist = Math.hypot(p.target.x - p.x, p.target.y - p.y);
            if (dist < 20 || p.target.hp <= 0) {
                if (p.target.hp > 0) {
                    let dmg = p.owner.dmg; if(Math.random()<0.1) dmg *= 1.5;
                    p.target.hp -= dmg; soundManager.playHit();
                    spawnFloatingText(p.target.x, p.target.y-40, `-${Math.floor(dmg)}`, '#FF0000');
                    if (p.target.hp<=0) { p.target.hp=0; if(p.target.team==='player') battleState.deadUnitIds.push(p.target.originalId); }
                    renderState.effects.push({x: p.target.x, y: p.target.y, life: 10, color: '#FFF'});
                }
                battleState.projectiles.splice(i, 1);
            } else { p.x += ((p.target.x - p.x)/dist)*20; p.y += ((p.target.y - p.y)/dist)*20; }
        }
        if (battleState.phase === 'INIT') { battleState.phaseTimer -= dt; if(battleState.phaseTimer<=0) battleState.phase = 'PLAYER_FIRE'; }
        else if (battleState.phase === 'PLAYER_FIRE') { fireTeam(battleState.playerTeam, battleState.enemyTeam, '#0F0'); battleState.phase = 'WAIT_PLAYER'; }
        else if (battleState.phase === 'WAIT_PLAYER') { if(battleState.projectiles.length === 0) battleState.phase = 'CHECK_P'; }
        else if (battleState.phase === 'CHECK_P') { if(!battleState.enemyTeam.some(u => u.hp > 0)) finishBattle(true); else battleState.phase = 'ENEMY_FIRE'; }
        else if (battleState.phase === 'ENEMY_FIRE') { fireTeam(battleState.enemyTeam, battleState.playerTeam, '#F00'); battleState.phase = 'WAIT_ENEMY'; }
        else if (battleState.phase === 'WAIT_ENEMY') { if(battleState.projectiles.length === 0) battleState.phase = 'CHECK_E'; }
        else if (battleState.phase === 'CHECK_E') { if(!battleState.playerTeam.some(u => u.hp > 0)) finishBattle(false); else battleState.phase = 'PLAYER_FIRE'; }
    }
    function fireTeam(source, targets, color) {
        const aliveSrc = source.filter(u => u.hp > 0); const aliveTgt = targets.filter(u => u.hp > 0);
        if(aliveSrc.length && aliveTgt.length) {
            aliveSrc.forEach(u => {
                const t = aliveTgt[Math.floor(Math.random()*aliveTgt.length)];
                battleState.projectiles.push({x: u.x, y: u.y, target: t, owner: u, color: color});
            });
            soundManager.playAttack();
        }
    }
    function finishBattle(win) {
        gameState.mode = 'RESULT'; const t = TRANSLATION[gameState.lang] || TRANSLATION.en;
        document.getElementById('resultTitle').innerText = win ? t.WIN : t.LOSE;
        document.getElementById('resultTitle').className = win ? 'result-title win' : 'result-title lose';
        if (win) {
            const reward = 3 * getBuyCost(getSmartShopState().level); gameState.coins += reward;
            document.getElementById('resultReward').innerText = `${t.REWARD}: +${formatNumber(reward)}$`; soundManager.playWin();
        } else { document.getElementById('resultReward').innerText = ""; soundManager.playLose(); }
        const deadBlock = document.getElementById('deadHeroesBlock');
        if (battleState.deadUnitIds.length > 0) {
            deadBlock.style.display = 'block'; gameState.units = gameState.units.filter(u => !battleState.deadUnitIds.includes(u.id));
            document.getElementById('deadListText').innerText = `-${battleState.deadUnitIds.length} units`;
        } else { deadBlock.style.display = 'none'; }
        saveGame(); document.getElementById('battleResultOverlay').style.display = 'flex';
    }
    document.getElementById('continueBtn').onclick = () => {
        document.getElementById('battleResultOverlay').style.display = 'none';
        yandexManager.showInterstitial(() => { gameState.challengeTimer = CONFIG.BATTLE_INTERVAL_MIN + Math.random() * 15; gameState.mode = 'MERGE'; resize(); });
    };

    // ------------------------------------------
    // --- SMART RESIZE & RENDER ARCHITECTURE ---
    // ------------------------------------------

    function initGrid() {
        // Just creates the logical slots based on current layout parameters
        renderState.slots = [];
        for(let r=0; r<CONFIG.gridRows; r++) {
            for(let c=0; c<CONFIG.gridCols; c++) {
                renderState.slots.push({
                    x: layout.gridX + c * (CONFIG.slotSize + CONFIG.slotMargin),
                    y: layout.gridY + r * (CONFIG.slotSize + CONFIG.slotMargin),
                    width: CONFIG.slotSize,
                    height: CONFIG.slotSize,
                    index: r * CONFIG.gridCols + c
                });
            }
        }
    }

    function updateUIButtons(w, h) {
        const minDim = Math.min(w, h);
        
        // Settings Anchor (Top-Left)
        const pad = Math.max(15, minDim * 0.04);
        const setRadius = Math.max(20, minDim * 0.05); 
        
        const settingsBtn = { id:'settings', x: pad + setRadius, y: pad + setRadius, r: setRadius, color:'#777', visible: true };
        const muteBtn = { id:'mute', x: settingsBtn.x, y: settingsBtn.y + setRadius * 2.5, r: setRadius * 0.9, color:'#444', visible: gameState.settingsOpen };
        const langBtn = { id:'lang', x: settingsBtn.x, y: settingsBtn.y + setRadius * 5.0, r: setRadius * 0.9, color:'#4488FF', visible: gameState.settingsOpen };

        // Action Buttons (Buy & Ad)
        let buyBtn, adBtn;
        
        const actionBtnRadius = Math.max(30, minDim * 0.08); // Big enough for touch

        if (layout.isPortrait) {
            // PORTRAIT: Buttons at bottom
            const btnY = h - actionBtnRadius - pad - 10;
            adBtn = { id:'ad', x: w * 0.25, y: btnY, r: actionBtnRadius * 0.9, color:'#FFD700', visible: true };
            buyBtn = { id:'buy', x: w * 0.75, y: btnY, r: actionBtnRadius * 1.1, color:'#4CAF50', visible: true };
        } else {
            // LANDSCAPE: Buttons on sides
            const btnY = h / 2 + 30; // Slightly offset down from true center to clear money text area
            adBtn = { id:'ad', x: pad + actionBtnRadius, y: btnY, r: actionBtnRadius * 0.8, color:'#FFD700', visible: true };
            buyBtn = { id:'buy', x: w - pad - actionBtnRadius, y: btnY, r: actionBtnRadius, color:'#4CAF50', visible: true };
        }

        renderState.uiButtons = [settingsBtn, muteBtn, langBtn, adBtn, buyBtn];
    }

    function resize() {
        // 1. High DPI Scaling
        const dpr = window.devicePixelRatio || 1;
        const w = window.innerWidth;
        const h = window.innerHeight;

        // Set physical size
        canvas.width = w * dpr;
        canvas.height = h * dpr;
        
        // Set CSS size
        canvas.style.width = w + 'px';
        canvas.style.height = h + 'px';

        // Scale context
        ctx.resetTransform();
        ctx.scale(dpr, dpr);

        // --- NEW: STRICT PORTRAIT LOCK FOR MOBILE ---
        const isPortrait = h > w;
        // Robust mobile check: checks for mobile UA string or touch capabilities combined with hover limitations
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                         (navigator.maxTouchPoints > 0 && window.matchMedia("(hover: none)").matches);

        const rotOverlay = document.getElementById('rotateOverlay');
        const rotMsg = document.getElementById('rotateMsg');
        
        if (isMobile && isPortrait) {
            // SHOW OVERLAY
            if(rotOverlay.style.display !== 'flex') {
                rotOverlay.style.display = 'flex';
                // Pause Game
                gameState.paused = true;
                if(soundManager.ctx && soundManager.ctx.state === 'running') soundManager.ctx.suspend();
            }
            // Update Text (in case language changed)
            const t = TRANSLATION[gameState.lang] || TRANSLATION.en;
            rotMsg.innerText = t.ROTATE_MSG;
            
            // STOP here. Do not calculate layout for a blocked screen.
            return; 
        } else {
            // HIDE OVERLAY (if visible)
            if(rotOverlay.style.display === 'flex') {
                rotOverlay.style.display = 'none';
                gameState.paused = false;
                if(soundManager.ctx && soundManager.ctx.state === 'suspended' && !soundManager.muted) soundManager.ctx.resume();
            }
        }

        // 2. Determine Orientation & Metrics (For Game Layout)
        layout.isPortrait = isPortrait; // Use the calculated value from above
        layout.scale = Math.min(w, h) / 400; // Reference scale
        layout.fontSize = Math.max(16, h * 0.035); // Responsive Font

        // 3. Smart Grid Calculation
        const uiPadding = 20;
        const topSafeZone = Math.max(60, h * 0.15); // Money/Settings area
        
        let bottomSafeZone = uiPadding;
        let sideSafeZone = uiPadding;

        // If we are here, it's either Desktop (Portrait/Landscape) or Mobile Landscape.
        // We still support portrait layout for Desktop users resizing windows.
        if (layout.isPortrait) {
            bottomSafeZone = h * 0.22; // Reserve space for bottom buttons
        } else {
            sideSafeZone = w * 0.18; // Reserve space for side buttons
        }

        const availW = w - (sideSafeZone * 2);
        const availH = h - topSafeZone - bottomSafeZone;

        // Calculate maximum possible slot size
        const maxSlotW = (availW - (CONFIG.gridCols - 1) * CONFIG.slotMargin) / CONFIG.gridCols;
        const maxSlotH = (availH - (CONFIG.gridRows - 1) * CONFIG.slotMargin) / CONFIG.gridRows;
        
        // Set slot size (clamped)
        CONFIG.slotSize = Math.floor(Math.min(maxSlotW, maxSlotH));
        
        // 4. Center the Grid
        const gridRealW = CONFIG.gridCols * CONFIG.slotSize + (CONFIG.gridCols - 1) * CONFIG.slotMargin;
        const gridRealH = CONFIG.gridRows * CONFIG.slotSize + (CONFIG.gridRows - 1) * CONFIG.slotMargin;

        layout.gridX = (w - gridRealW) / 2;
        layout.gridY = topSafeZone + (availH - gridRealH) / 2;

        // 5. Re-init objects
        initGrid();
        updateUIButtons(w, h);

        // 6. Snap existing units
        if (gameState.mode === 'MERGE') {
            gameState.units.forEach(u => {
                if (!u.isDragging) ret(u);
            });
        }
    }

    function drawStrokedText(text, x, y, size, color, align = 'center') {
        ctx.font = `900 ${size}px "Arial Black", Verdana, sans-serif`;
        ctx.textAlign = align;
        ctx.textBaseline = 'middle';
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = Math.max(3, size / 8); 
        ctx.lineJoin = 'round';
        ctx.strokeText(text, x, y);
        ctx.fillStyle = color;
        ctx.fillText(text, x, y);
    }

    function render() {
        // Clear logic for High DPI (use mapped coordinates)
        ctx.clearRect(0, 0, canvas.width / window.devicePixelRatio, canvas.height / window.devicePixelRatio);
        const w = window.innerWidth;
        const h = window.innerHeight;

        if (gameState.mode === 'BATTLE') {
            // Battle rendering (simplified)
            ctx.fillStyle = '#0b0d17'; ctx.fillRect(0,0,w,h);
            ctx.fillStyle = '#FFF'; renderState.stars.forEach(s => { ctx.globalAlpha=Math.random()*0.5+0.5; ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, Math.PI*2); ctx.fill(); }); ctx.globalAlpha=1;
            
            const unitSize = battleState.unitSize || 60; // Use dynamic size

            [...battleState.playerTeam, ...battleState.enemyTeam].forEach(u => {
                if(u.hp <= 0) return;
                
                // Draw Health Bar relative to unit position and size
                const hpPct = u.hp/u.maxHp; 
                const barW = unitSize * 0.8;
                const barH = Math.max(4, unitSize * 0.1);
                const barY = -unitSize * 0.6; // Above unit

                ctx.fillStyle = '#333'; ctx.fillRect(u.x - barW/2, u.y + barY, barW, barH); 
                ctx.fillStyle = hpPct>0.5?'#0F0':'#F00'; ctx.fillRect(u.x - barW/2, u.y + barY, barW*hpPct, barH);
                
                // Draw Unit
                ctx.save(); 
                ctx.translate(u.x, u.y); 
                if(u.team === 'enemy') ctx.scale(-1, 1); 
                drawCharacter(ctx, 0, 0, unitSize, u.level); 
                ctx.restore();
            });
            battleState.projectiles.forEach(p => { ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, 8, 0, Math.PI*2); ctx.fill(); ctx.shadowColor=p.color; ctx.shadowBlur=10; ctx.stroke(); ctx.shadowBlur=0; });
        
        } else {
            // --- MERGE MODE RENDERING ---
            
            // Background
            ctx.fillStyle = '#2c3e50'; ctx.fillRect(0,0,w,h);
            ctx.strokeStyle = 'rgba(255,255,255,0.05)'; ctx.lineWidth=2; ctx.beginPath();
            for(let x=0;x<=w;x+=50){ctx.moveTo(x,0);ctx.lineTo(x,h);} for(let y=0;y<=h;y+=50){ctx.moveTo(0,y);ctx.lineTo(w,y);} ctx.stroke();
            
            // Slots
            renderState.slots.forEach(s => { ctx.fillStyle = CONFIG.gridColor; ctx.beginPath(); ctx.roundRect(s.x, s.y, s.width, s.height, 10); ctx.fill(); ctx.strokeStyle='#383C41'; ctx.lineWidth=2; ctx.stroke(); });
            
            // Units
            gameState.units.forEach(u => {
                if (u.animScale < 1.0) u.animScale = Math.min(1.0, u.animScale+0.1);
                const size = CONFIG.slotSize * 0.8; 
                ctx.save(); ctx.translate(u.x, u.y); ctx.scale(1 + (1-u.animScale)*0.5, u.animScale);
                if(u.isDragging) { ctx.shadowColor='rgba(0,0,0,0.5)'; ctx.shadowBlur=15; ctx.shadowOffsetY=10; } 
                drawCharacter(ctx, 0, 0, size, u.level); 
                ctx.restore();
                
                // Unit Lvl Text
                const t = TRANSLATION[gameState.lang] || TRANSLATION.en;
                drawStrokedText(`${t.LVL} ${u.level}`, u.x, u.y + size/2 + 15, Math.max(10, CONFIG.slotSize * 0.15), '#FFFFFF');
            });

            const t = TRANSLATION[gameState.lang] || TRANSLATION.en;

            // Money Top Center
            drawStrokedText(`$ ${formatNumber(gameState.coins)}`, w / 2, Math.max(30, h * 0.05), Math.max(24, h * 0.05), '#FFD700');

            // UI BUTTONS
            renderState.uiButtons.forEach(btn => {
                if (!btn.visible) return;

                if(btn.id === 'buy') {
                    const s = getSmartShopState(); const cost = getBuyCost(s.level); const can = gameState.coins >= cost;
                    ctx.fillStyle = can ? btn.color : '#555'; ctx.beginPath(); ctx.arc(btn.x, btn.y, btn.r, 0, Math.PI*2); ctx.fill();
                    ctx.strokeStyle = (s.type === 'HELP' && can) ? '#FFA500' : '#FFF'; ctx.lineWidth = (s.type==='HELP')?4:2; ctx.stroke();
                    drawStrokedText(`Lvl ${s.level}`, btn.x, btn.y - btn.r * 0.15, btn.r * 0.35, can?'#FFF':'#AAA');
                    drawStrokedText(`${formatNumber(cost)}$`, btn.x, btn.y + btn.r * 0.35, btn.r * 0.45, can?'#FFF':'#AAA');
                } 
                else if(btn.id === 'ad') {
                    ctx.fillStyle = btn.color; ctx.beginPath(); ctx.arc(btn.x, btn.y, btn.r, 0, Math.PI*2); ctx.fill(); 
                    ctx.strokeStyle = '#FFF'; ctx.lineWidth = 2; ctx.stroke();
                    
                    // Icon
                    ctx.fillStyle = '#FFF'; ctx.beginPath();
                    const cx = btn.x + 2; const cy = btn.y - btn.r * 0.2; const s = btn.r * 0.3;
                    ctx.moveTo(cx - s, cy - s); ctx.lineTo(cx - s, cy + s); ctx.lineTo(cx + s, cy); ctx.fill();

                    // Text
                    ctx.font = `900 ${btn.r * 0.35}px "Arial Black", Verdana`;
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillStyle = '#000';
                    ctx.fillText(t.AD_BTN, btn.x, btn.y + btn.r * 0.4);
                } 
                else if(btn.id === 'settings') {
                    ctx.fillStyle = '#777'; ctx.beginPath(); ctx.arc(btn.x, btn.y, btn.r, 0, Math.PI*2); ctx.fill();
                    ctx.strokeStyle = '#FFF'; ctx.lineWidth = 2; ctx.stroke();
                    ctx.save(); ctx.translate(btn.x, btn.y);
                    ctx.fillStyle = '#DDD'; ctx.beginPath(); ctx.arc(0,0,btn.r*0.5,0,Math.PI*2); ctx.fill();
                    for(let i=0; i<8; i++) { ctx.rotate(Math.PI/4); ctx.fillRect(btn.r*0.5, -btn.r*0.15, btn.r*0.3, btn.r*0.3); }
                    ctx.restore();
                }
                else if(btn.id === 'mute') {
                    ctx.fillStyle = '#444'; ctx.beginPath(); ctx.arc(btn.x, btn.y, btn.r, 0, Math.PI*2); ctx.fill();
                    ctx.strokeStyle = '#FFF'; ctx.lineWidth = 1; ctx.stroke();
                    drawStrokedText(soundManager.muted ? "üîá" : "üîä", btn.x, btn.y+2, btn.r, '#FFF');
                }
                else if(btn.id === 'lang') {
                    ctx.fillStyle = '#4488FF'; ctx.beginPath(); ctx.arc(btn.x, btn.y, btn.r, 0, Math.PI*2); ctx.fill();
                    ctx.strokeStyle = '#FFF'; ctx.lineWidth = 1; ctx.stroke();
                    drawStrokedText(gameState.lang.toUpperCase(), btn.x, btn.y+2, btn.r * 0.7, '#FFF');
                }
            });
        }
        
        // Effects
        renderState.floatingTexts.forEach(ft => { 
            ft.y -= ft.vy; ft.life -= 0.02; 
            ctx.globalAlpha = Math.max(0, ft.life); 
            drawStrokedText(ft.text, ft.x, ft.y, ft.size, ft.color);
            ctx.globalAlpha = 1; 
        }); 
        renderState.floatingTexts = renderState.floatingTexts.filter(ft => ft.life > 0);
        
        renderState.effects.forEach(fx => { fx.life--; ctx.globalAlpha = fx.life/20; ctx.fillStyle=fx.color; ctx.beginPath(); ctx.arc(fx.x, fx.y, 40*(1-fx.life/40), 0, Math.PI*2); ctx.fill(); ctx.globalAlpha=1; }); renderState.effects = renderState.effects.filter(fx => fx.life > 0);
    }
    
    function drawCharacter(ctx, x, y, size, level) {
        ctx.fillStyle = getUnitColor(level); ctx.strokeStyle = '#000'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.roundRect(-size*0.4, -size*0.2, size*0.2, size*0.6, 5); ctx.fill(); ctx.stroke();
        ctx.beginPath(); ctx.ellipse(0, 0, size*0.25, size*0.35, 0, 0, Math.PI*2); ctx.fill(); ctx.stroke();
        ctx.fillStyle = '#75D5E6'; ctx.beginPath(); ctx.ellipse(size*0.1, -size*0.1, size*0.15, size*0.1, 0, 0, Math.PI*2); ctx.fill(); ctx.stroke();
        if(level > 10) { ctx.fillStyle = '#FFD700'; ctx.beginPath(); ctx.moveTo(-10, -size*0.4); ctx.lineTo(-5, -size*0.6); ctx.lineTo(0, -size*0.4); ctx.lineTo(5, -size*0.6); ctx.lineTo(10, -size*0.4); ctx.fill(); }
    }

    // --- LOGIC: INPUT ---
    let dragTarget=null, dragSX=0, dragSY=0, dragOX=0, dragOY=0;
    
    function handleInputStart(x, y) {
        soundManager.checkContext();
        if (gameState.mode !== 'MERGE') return;
        
        const muteBtn = renderState.uiButtons.find(b => b.id === 'mute');
        const langBtn = renderState.uiButtons.find(b => b.id === 'lang');
        if(muteBtn) muteBtn.visible = gameState.settingsOpen;
        if(langBtn) langBtn.visible = gameState.settingsOpen;

        for (let btn of renderState.uiButtons) {
            if (!btn.visible) continue;
            
            if (Math.hypot(x-btn.x, y-btn.y) <= btn.r) {
                soundManager.playClick();
                
                if(btn.id === 'settings') {
                    gameState.settingsOpen = !gameState.settingsOpen;
                    // Force update button state
                    const m = renderState.uiButtons.find(b => b.id === 'mute');
                    const l = renderState.uiButtons.find(b => b.id === 'lang');
                    if(m) m.visible = gameState.settingsOpen;
                    if(l) l.visible = gameState.settingsOpen;
                }
                else if(btn.id==='buy') spawnUnit();
                else if(btn.id==='ad') {
                    yandexManager.showRewarded(() => { 
                        const r = Math.floor(200*Math.pow(1.5, gameState.maxLevel)); 
                        gameState.coins += r; 
                        spawnFloatingText(canvas.width/2/window.devicePixelRatio, canvas.height/2/window.devicePixelRatio, `+${formatNumber(r)}$`, '#FFD700', 30); 
                        soundManager.playWin(); 
                        saveGame(); 
                    });
                }
                else if(btn.id==='mute') soundManager.setMute(!soundManager.muted);
                else if(btn.id==='lang') { gameState.lang = gameState.lang === 'ru' ? 'en' : 'ru'; updateDomTexts(); }
                return;
            }
        }
        for (let i = gameState.units.length - 1; i >= 0; i--) { const u = gameState.units[i]; if (Math.hypot(x-u.x, y-u.y) < (CONFIG.slotSize/2+5)) { dragTarget=u; dragTarget.isDragging=false; dragSX=x; dragSY=y; dragOX=x-u.x; dragOY=y-u.y; gameState.units.splice(i, 1); gameState.units.push(u); return; } }
    }
    function handleInputMove(x, y) { if (dragTarget && gameState.mode === 'MERGE') { dragTarget.x = x - dragOX; dragTarget.y = y - dragOY; if (!dragTarget.isDragging && Math.hypot(x-dragSX, y-dragSY)>5) dragTarget.isDragging=true; } }
    function handleInputEnd(x, y) {
        if (dragTarget) {
            if (Math.hypot(x-dragSX, y-dragSY) < 5) {
                let inc = getClickIncome(dragTarget.level); const isCrit = Math.random() < 0.15;
                if(isCrit) { inc *= 5; soundManager.playHit(); } else soundManager.playClick(); gameState.coins += inc;
                spawnFloatingText(dragTarget.x, dragTarget.y-30, `${isCrit?'CRIT! ':''}+${formatNumber(inc)}$`, isCrit?'#FF4500':'#4CAF50', isCrit?24:16); dragTarget.animScale = 0.8; ret(dragTarget);
            } else {
                dragTarget.isDragging = false; const realSlot = renderState.slots.find(s => x>=s.x && x<=s.x+s.width && y>=s.y && y<=s.y+s.height);
                if (realSlot) {
                    const target = gameState.units.find(u => u.slotIndex === realSlot.index && u.id !== dragTarget.id);
                    if (target && target.level === dragTarget.level) {
                        const newLvl = target.level + 1; if(newLvl > gameState.maxLevel) gameState.maxLevel = newLvl;
                        renderState.effects.push({x: realSlot.x+realSlot.width/2, y: realSlot.y+realSlot.height/2, life: 20, color: '#FFF'});
                        gameState.units = gameState.units.filter(u => u.id !== dragTarget.id && u.id !== target.id);
                        gameState.units.push({id: Date.now(), level: newLvl, slotIndex: realSlot.index, x: realSlot.x+realSlot.width/2, y: realSlot.y+realSlot.height/2, isDragging: false, animScale: 0.1});
                        soundManager.playMerge(); saveGame();
                    } else if (!target) { dragTarget.slotIndex = realSlot.index; snap(dragTarget, realSlot); saveGame(); } else ret(dragTarget);
                } else ret(dragTarget);
            }
            dragTarget = null;
        }
    }
    function snap(u, s) { u.x=s.x+s.width/2; u.y=s.y+s.height/2; }
    function ret(u) { const s = renderState.slots.find(sl=>sl.index === u.slotIndex); if(s) snap(u, s); }
    function spawnFloatingText(x, y, text, color, size=20) { renderState.floatingTexts.push({x, y, text, color, size, life: 1.0, vy: 2}); }
    function spawnUnit() {
        const s = getSmartShopState(); const cost = getBuyCost(s.level);
        if (gameState.coins >= cost) {
            const occ = gameState.units.map(u=>u.slotIndex); const free = renderState.slots.filter(s=>!occ.includes(s.index));
            if(free.length) { gameState.coins -= cost; const sl = free[Math.floor(Math.random()*free.length)]; gameState.units.push({id: Date.now()+Math.random(), level: s.level, slotIndex: sl.index, x: sl.x+sl.width/2, y: sl.y+sl.height/2, isDragging: false, animScale: 0.1}); soundManager.playBuy(); saveGame(); }
        }
    }
    function updateDomTexts() {
        const t = TRANSLATION[gameState.lang] || TRANSLATION.en;
        document.getElementById('chalTitle').innerText = t.CHALLENGE; document.getElementById('btnAccept').innerText = t.ACCEPT; document.getElementById('btnDecline').innerText = t.DECLINE; document.getElementById('setupTitle').innerText = t.PREPARE; document.getElementById('squadTitle').innerText = t.SQUAD; document.getElementById('enemyTitle').innerText = t.ENEMY; document.getElementById('fightBtn').innerText = t.FIGHT; document.getElementById('fallenTitle').innerText = t.FALLEN; document.getElementById('continueBtn').innerText = t.CONT;
    }
    canvas.addEventListener('mousedown', e=>handleInputStart(e.clientX, e.clientY)); window.addEventListener('mousemove', e=>handleInputMove(e.clientX, e.clientY)); window.addEventListener('mouseup', e=>handleInputEnd(e.clientX, e.clientY));
    canvas.addEventListener('touchstart', e=>{e.preventDefault(); handleInputStart(e.touches[0].clientX, e.touches[0].clientY)}, {passive:false});
    canvas.addEventListener('touchmove', e=>{e.preventDefault(); handleInputMove(e.touches[0].clientX, e.touches[0].clientY)}, {passive:false});
    canvas.addEventListener('touchend', e=>{e.preventDefault(); handleInputEnd(e.changedTouches[0].clientX, e.changedTouches[0].clientY)}, {passive:false});
    document.addEventListener('visibilitychange', () => { if (document.hidden) { gameState.paused = true; if(soundManager.ctx) soundManager.ctx.suspend(); yandexManager.gameplayStop(); } else { gameState.paused = false; if(!soundManager.muted && soundManager.ctx) soundManager.ctx.resume(); yandexManager.gameplayStart(); } });
    function saveGame() { localStorage.setItem('amg_save', JSON.stringify({ coins: gameState.coins, maxLevel: gameState.maxLevel, units: gameState.units.map(u => ({level: u.level, slotIndex: u.slotIndex})) })); }
    function loadGame() { try { const d = JSON.parse(localStorage.getItem('amg_save')); if(d) { gameState.coins=d.coins||0; gameState.maxLevel=d.maxLevel||1; gameState.units=(d.units||[]).map(u=>({id:Date.now()+Math.random(), level:u.level, slotIndex:u.slotIndex, x:0, y:0, isDragging:false, animScale:1})); } } catch(e){} }
    if (!CanvasRenderingContext2D.prototype.roundRect) { CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) { if (w<2*r) r=w/2; if(h<2*r) r=h/2; this.beginPath(); this.moveTo(x+r, y); this.arcTo(x+w, y, x+w, y+h, r); this.arcTo(x+w, y+h, x, y+h, r); this.arcTo(x+w, y+h, x, y+h, r); this.arcTo(x, y+h, x, y, r); this.arcTo(x, y, x+w, y, r); this.closePath(); return this; }; }

    // --- MAIN INITIALIZATION SEQUENCE ---
    window.onload = async () => {
        await yandexManager.init();
        loadGame();
        if(!gameState.units.length) gameState.units.push({id:Date.now(),level:1,slotIndex:0,x:0,y:0,isDragging:false,animScale:1});
        
        window.addEventListener('resize', resize);
        resize(); // Initial smart layout calc
        updateDomTexts();
        
        document.getElementById('loadingOverlay').style.display = 'none';
        yandexManager.notifyGameReady();
        yandexManager.gameplayStart();
        requestAnimationFrame(gameLoop);
    };
</script>
</body>
</html>
